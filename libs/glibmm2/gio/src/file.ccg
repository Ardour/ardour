// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* Copyright (C) 2007 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <giomm/mount.h>
#include <gio/gio.h>
#include <utility>
#include <glibmm/error.h>
#include <glibmm/exceptionhandler.h>
#include "slot_async.h"

namespace
{

typedef std::pair<Gio::File::SlotReadMore*, Gio::SlotAsyncReady*> LoadPartialSlots;

static void
SignalProxy_file_progress_callback(goffset current_num_bytes,
                                   goffset total_num_bytes,
                                   gpointer data)
{
  Gio::File::SlotFileProgress* the_slot = static_cast<Gio::File::SlotFileProgress*>(data);

  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  try
  {
  #endif //GLIBMM_EXCEPTIONS_ENABLED

    (*the_slot)(current_num_bytes, total_num_bytes);

  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }
  #endif //GLIBMM_EXCEPTIONS_ENABLED

  delete the_slot;
}

static gboolean
SignalProxy_load_partial_contents_read_more_callback(const char* file_contents, goffset file_size, gpointer data)
{
  LoadPartialSlots* slot_pair = static_cast<LoadPartialSlots*>(data);
  Gio::File::SlotReadMore* the_slot = slot_pair->first;

  bool result = false;

  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  try
  {
  #endif //GLIBMM_EXCEPTIONS_ENABLED

    result = (*the_slot)(file_contents, file_size);

  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }
  #endif //GLIBMM_EXCEPTIONS_ENABLED

  return result;
}

// Same as SignalProxy_async_callback, except that this one knows that
// the slot is packed in a pair. The operation is assumed to be finished
// after the callback is triggered, so we delete that pair here.
static void
SignalProxy_load_partial_contents_ready_callback(GObject*, GAsyncResult* res, void* data)
{
  LoadPartialSlots* slot_pair = static_cast<LoadPartialSlots*>(data);
  Gio::SlotAsyncReady* the_slot = slot_pair->second;

  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  try
  {
  #endif //GLIBMM_EXCEPTIONS_ENABLED
    Glib::RefPtr<Gio::AsyncResult> result = Glib::wrap(res, true /* take copy */);
    (*the_slot)(result);
  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }
  #endif //GLIBMM_EXCEPTIONS_ENABLED

  delete the_slot;
  delete slot_pair->first; // read_more slot
  delete slot_pair;
}

} // anonymous namespace

namespace Gio {

Glib::RefPtr<File>
File::create_for_path(const std::string& path)
{
  GFile* cfile = g_file_new_for_path(path.c_str());
  return Glib::wrap(G_FILE(cfile));
}

Glib::RefPtr<File>
File::create_for_uri(const std::string& uri)
{
  GFile* cfile = g_file_new_for_uri(uri.c_str());
  return Glib::wrap(G_FILE(cfile));
}

Glib::RefPtr<File>
File::create_for_commandline_arg(const std::string& arg)
{
  GFile* cfile = g_file_new_for_commandline_arg(arg.c_str());
  return Glib::wrap(G_FILE(cfile));
}

Glib::RefPtr<File>
File::create_for_parse_name(const Glib::ustring& parse_name)
{
  GFile* cfile = g_file_parse_name(parse_name.c_str());
  return Glib::wrap(G_FILE(cfile));
}

void
File::read_async(const SlotAsyncReady& slot, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_read_async(gobj(),
                    io_priority,
                    NULL,
                    &SignalProxy_async_callback,
                    slot_copy);
}

void
File::read_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_read_async(gobj(),
                    io_priority,
                    cancellable->gobj(),
                    &SignalProxy_async_callback,
                    slot_copy);
}

void
File::append_to_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, FileCreateFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_append_to_async(gobj(),
                         static_cast<GFileCreateFlags>(flags),
                         io_priority,
                         cancellable->gobj(),
                         &SignalProxy_async_callback,
                         slot_copy);
}

void
File::append_to_async(const SlotAsyncReady& slot, FileCreateFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_append_to_async(gobj(),
                         static_cast<GFileCreateFlags>(flags),
                         io_priority,
                         NULL, // cancellable
                         &SignalProxy_async_callback,
                         slot_copy);
}

void
File::create_file_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, FileCreateFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_create_async(gobj(),
                      static_cast<GFileCreateFlags>(flags),
                      io_priority,
                      cancellable->gobj(),
                      &SignalProxy_async_callback,
                      slot_copy);
}

void
File::create_file_async(const SlotAsyncReady& slot, FileCreateFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_create_async(gobj(),
                      static_cast<GFileCreateFlags>(flags),
                      io_priority,
                      NULL, // cancellable
                      &SignalProxy_async_callback,
                      slot_copy);
}

void
File::replace_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, const std::string& etag, bool make_backup, FileCreateFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_replace_async(gobj(),
                       etag.empty() ? NULL : etag.c_str(),
                       make_backup,
                       static_cast<GFileCreateFlags>(flags),
                       io_priority,
                       cancellable->gobj(),
                       &SignalProxy_async_callback,
                       slot_copy);
}

void
File::replace_async(const SlotAsyncReady& slot, const std::string& etag, bool make_backup, FileCreateFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_replace_async(gobj(),
                       etag.empty() ? NULL : etag.c_str(),
                       make_backup,
                       static_cast<GFileCreateFlags>(flags),
                       io_priority,
                       NULL, // cancellable
                       &SignalProxy_async_callback,
                       slot_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileInfo> File::query_info(const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, FileQueryInfoFlags flags) const
#else
Glib::RefPtr<FileInfo> File::query_info(const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error) const
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileInfo> retvalue = Glib::wrap(g_file_query_info(const_cast<GFile*>(gobj()), attributes.c_str(), ((GFileQueryInfoFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileInfo> File::query_info(const std::string& attributes, FileQueryInfoFlags flags) const
#else
Glib::RefPtr<FileInfo> File::query_info(const std::string& attributes, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error) const
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileInfo> retvalue = Glib::wrap(g_file_query_info(const_cast<GFile*>(gobj()), attributes.c_str(), ((GFileQueryInfoFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

bool File::query_exists() const
{
  return g_file_query_exists(const_cast<GFile*>(gobj()), NULL);
}

FileType File::query_file_type(FileQueryInfoFlags flags) const
{
  return (FileType)g_file_query_file_type(const_cast<GFile*>(gobj()), (GFileQueryInfoFlags)flags, NULL);
}

void
File::query_info_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, FileQueryInfoFlags flags, int io_priority) const
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_query_info_async(const_cast<GFile*>(gobj()),
                          attributes.c_str(),
                          static_cast<GFileQueryInfoFlags>(flags),
                          io_priority,
                          cancellable->gobj(),
                          &SignalProxy_async_callback,
                          slot_copy);
}

void
File::query_info_async(const SlotAsyncReady& slot, const std::string& attributes, FileQueryInfoFlags flags, int io_priority) const
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_query_info_async(const_cast<GFile*>(gobj()),
                          attributes.c_str(),
                          static_cast<GFileQueryInfoFlags>(flags),
                          io_priority,
                          NULL, // cancellable
                          &SignalProxy_async_callback,
                          slot_copy);
}


#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileInfo> File::query_filesystem_info(const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes)
#else
Glib::RefPtr<FileInfo> File::query_filesystem_info(const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileInfo> retvalue = Glib::wrap(g_file_query_filesystem_info(gobj(), attributes.c_str(), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileInfo> File::query_filesystem_info(const std::string& attributes)
#else
Glib::RefPtr<FileInfo> File::query_filesystem_info(const std::string& attributes, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileInfo> retvalue = Glib::wrap(g_file_query_filesystem_info(gobj(), attributes.c_str(), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

void
File::query_filesystem_info_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, int io_priority) const
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_query_filesystem_info_async(const_cast<GFile*>(gobj()),
                          attributes.c_str(),
                          io_priority,
                          cancellable->gobj(),
                          &SignalProxy_async_callback,
                          slot_copy);
}

void
File::query_filesystem_info_async(const SlotAsyncReady& slot, const std::string& attributes, int io_priority) const
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_query_filesystem_info_async(const_cast<GFile*>(gobj()),
                          attributes.c_str(),
                          io_priority,
                          NULL, // cancellable
                          &SignalProxy_async_callback,
                          slot_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileEnumerator> File::enumerate_children(const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, FileQueryInfoFlags flags)
#else
Glib::RefPtr<FileEnumerator> File::enumerate_children(const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileEnumerator> retvalue = Glib::wrap(g_file_enumerate_children(gobj(), attributes.c_str(), ((GFileQueryInfoFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileEnumerator> File::enumerate_children(const std::string& attributes, FileQueryInfoFlags flags)
#else
Glib::RefPtr<FileEnumerator> File::enumerate_children(const std::string& attributes, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileEnumerator> retvalue = Glib::wrap(g_file_enumerate_children(gobj(), attributes.c_str(), ((GFileQueryInfoFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

void
File::enumerate_children_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, const std::string& attributes, FileQueryInfoFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_enumerate_children_async(gobj(),
                                  attributes.c_str(),
                                  static_cast<GFileQueryInfoFlags>(flags),
                                  io_priority,
                                  cancellable->gobj(),
                                  &SignalProxy_async_callback,
                                  slot_copy);
}

void
File::enumerate_children_async(const SlotAsyncReady& slot, const std::string& attributes, FileQueryInfoFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_enumerate_children_async(gobj(),
                                  attributes.c_str(),
                                  static_cast<GFileQueryInfoFlags>(flags),
                                  io_priority,
                                  NULL,
                                  &SignalProxy_async_callback,
                                  slot_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<File> File::set_display_name(const Glib::ustring& display_name)
#else
Glib::RefPtr<File> File::set_display_name(const Glib::ustring& display_name, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<File> retvalue = Glib::wrap(g_file_set_display_name(gobj(), display_name.c_str(), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;

}

void
File::set_display_name_async(const Glib::ustring& display_name, const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_set_display_name_async(gobj(),
                                display_name.c_str(),
                                io_priority,
                                cancellable->gobj(),
                                &SignalProxy_async_callback,
                                slot_copy);
}

void
File::set_display_name_async(const Glib::ustring& display_name, const SlotAsyncReady& slot, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_set_display_name_async(gobj(),
                                display_name.c_str(),
                                io_priority,
                                NULL,
                                &SignalProxy_async_callback,
                                slot_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::copy(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, const Glib::RefPtr<Cancellable>& cancellable, FileCopyFlags flags)
#else
bool
File::copy(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, const Glib::RefPtr<Cancellable>& cancellable, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res;

  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotFileProgress* slot_copy = new SlotFileProgress(slot);

  res = g_file_copy(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    cancellable->gobj(),
                    &SignalProxy_file_progress_callback,
                    slot_copy,
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::copy(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, FileCopyFlags flags)
#else
bool
File::copy(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res;

  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotFileProgress* slot_copy = new SlotFileProgress(slot);

  res = g_file_copy(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    NULL,
                    &SignalProxy_file_progress_callback,
                    slot_copy,
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::copy(const Glib::RefPtr<File>& destination, FileCopyFlags flags)
#else
bool
File::copy(const Glib::RefPtr<File>& destination, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res = g_file_copy(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    NULL,
                    NULL,
                    NULL,
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

void
File::copy_async(const Glib::RefPtr<File>& destination,
                 const SlotFileProgress& slot_progress,
                 const SlotAsyncReady& slot_ready,
                 const Glib::RefPtr<Cancellable>& cancellable,
                 FileCopyFlags flags,
                 int io_priority)
{
  // Create copies of slots.
  // Pointers to them will be passed through the callbacks' data parameter
  // and deleted in the corresponding callback.
  SlotAsyncReady* slot_ready_copy = new SlotAsyncReady(slot_ready);
  SlotFileProgress* slot_progress_copy = new SlotFileProgress(slot_progress);

  g_file_copy_async(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    io_priority,
                    cancellable->gobj(),
                    &SignalProxy_file_progress_callback,
                    slot_progress_copy,
                    &SignalProxy_async_callback,
                    slot_ready_copy);
}

void
File::copy_async(const Glib::RefPtr<File>& destination,
                 const SlotAsyncReady& slot_ready,
                 const Glib::RefPtr<Cancellable>& cancellable,
                 FileCopyFlags flags,
                 int io_priority)
{
  // Create copies of slots.
  // Pointers to them will be passed through the callbacks' data parameter
  // and deleted in the corresponding callback.
  SlotAsyncReady* slot_ready_copy = new SlotAsyncReady(slot_ready);

  g_file_copy_async(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    io_priority,
                    cancellable->gobj(),
                    NULL,
                    NULL,
                    &SignalProxy_async_callback,
                    slot_ready_copy);
}

void
File::copy_async(const Glib::RefPtr<File>& destination,
                 const SlotFileProgress& slot_progress,
                 const SlotAsyncReady& slot_ready,
                 FileCopyFlags flags,
                 int io_priority)
{
  // Create copies of slots.
  // Pointers to them will be passed through the callbacks' data parameter
  // and deleted in the corresponding callback.
  SlotAsyncReady* slot_ready_copy = new SlotAsyncReady(slot_ready);
  SlotFileProgress* slot_progress_copy = new SlotFileProgress(slot_progress);

  g_file_copy_async(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    io_priority,
                    NULL,
                    &SignalProxy_file_progress_callback,
                    slot_progress_copy,
                    &SignalProxy_async_callback,
                    slot_ready_copy);
}

void
File::copy_async(const Glib::RefPtr<File>& destination,
                 const SlotAsyncReady& slot_ready,
                 FileCopyFlags flags,
                 int io_priority)
{
  // Create copies of slots.
  // Pointers to them will be passed through the callbacks' data parameter
  // and deleted in the corresponding callback.
  SlotAsyncReady* slot_ready_copy = new SlotAsyncReady(slot_ready);

  g_file_copy_async(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    io_priority,
                    NULL,
                    NULL,
                    NULL,
                    &SignalProxy_async_callback,
                    slot_ready_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::move(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, const Glib::RefPtr<Cancellable>& cancellable, FileCopyFlags flags)
#else
bool
File::move(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, const Glib::RefPtr<Cancellable>& cancellable, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res;

  // Create a move of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotFileProgress* slot_copy = new SlotFileProgress(slot);

  res = g_file_move(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    cancellable->gobj(),
                    &SignalProxy_file_progress_callback,
                    slot_copy,
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::move(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, FileCopyFlags flags)
#else
bool
File::move(const Glib::RefPtr<File>& destination, const SlotFileProgress& slot, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res;

  // Create a move of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotFileProgress* slot_copy = new SlotFileProgress(slot);

  res = g_file_move(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    NULL,
                    &SignalProxy_file_progress_callback,
                    slot_copy,
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::move(const Glib::RefPtr<File>& destination, FileCopyFlags flags)
#else
bool
File::move(const Glib::RefPtr<File>& destination, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res;

  res = g_file_move(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    NULL,
                    NULL,
                    NULL,
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

void
File::set_attributes_async(const Glib::RefPtr<FileInfo>& info, const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, FileQueryInfoFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_set_attributes_async(gobj(),
                              info->gobj(),
                              static_cast<GFileQueryInfoFlags>(flags),
                              io_priority,
                              cancellable->gobj(),
                              &SignalProxy_async_callback,
                              slot_copy);
}

void
File::set_attributes_async(const Glib::RefPtr<FileInfo>& info, const SlotAsyncReady& slot, FileQueryInfoFlags flags, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_set_attributes_async(gobj(),
                              info->gobj(),
                              static_cast<GFileQueryInfoFlags>(flags),
                              io_priority,
                              NULL,
                              &SignalProxy_async_callback,
                              slot_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::set_attributes_finish(const Glib::RefPtr<AsyncResult>& result,
                            const Glib::RefPtr<FileInfo>& info)
#else
bool
File::set_attributes_finish(const Glib::RefPtr<AsyncResult>& result,
                            const Glib::RefPtr<FileInfo>& info,
                            std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  GFileInfo* cinfo = info->gobj();
  bool res;

  res = g_file_set_attributes_finish(gobj(),
                                     result->gobj(),
                                     &cinfo,
                                     &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attribute_string(const std::string& attribute, const std::string& value, FileQueryInfoFlags flags)
#else
bool File::set_attribute_string(const std::string& attribute, const std::string& value, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attribute_string(gobj(), attribute.c_str(), value.c_str(), ((GFileQueryInfoFlags)(flags)), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;

}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attribute_byte_string(const std::string& attribute, const std::string& value, FileQueryInfoFlags flags)
#else
bool File::set_attribute_byte_string(const std::string& attribute, const std::string& value, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attribute_byte_string(gobj(), attribute.c_str(), value.c_str(), ((GFileQueryInfoFlags)(flags)), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;

}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attribute_uint32(const std::string& attribute, guint32 value, FileQueryInfoFlags flags)
#else
bool File::set_attribute_uint32(const std::string& attribute, guint32 value, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attribute_uint32(gobj(), attribute.c_str(), value, ((GFileQueryInfoFlags)(flags)), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;

}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attribute_int32(const std::string& attribute, gint32 value, FileQueryInfoFlags flags)
#else
bool File::set_attribute_int32(const std::string& attribute, gint32 value, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attribute_int32(gobj(), attribute.c_str(), value, ((GFileQueryInfoFlags)(flags)), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;

}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attribute_uint64(const std::string& attribute, guint64 value, FileQueryInfoFlags flags)
#else
bool File::set_attribute_uint64(const std::string& attribute, guint64 value, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attribute_uint64(gobj(), attribute.c_str(), value, ((GFileQueryInfoFlags)(flags)), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;

}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attribute_int64(const std::string& attribute, gint64 value, FileQueryInfoFlags flags)
#else
bool File::set_attribute_int64(const std::string& attribute, gint64 value, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attribute_int64(gobj(), attribute.c_str(), value, ((GFileQueryInfoFlags)(flags)), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;

}

void File::mount_mountable(const Glib::RefPtr<MountOperation>& mount_operation, const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, MountMountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_mount_mountable(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         mount_operation->gobj(),
                         cancellable->gobj(),
                         &SignalProxy_async_callback,
                         slot_copy);
}

void File::mount_mountable(const Glib::RefPtr<MountOperation>& mount_operation, const SlotAsyncReady& slot, MountMountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_mount_mountable(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         mount_operation->gobj(),
                         NULL,
                         &SignalProxy_async_callback,
                         slot_copy);
}

void File::mount_mountable(const SlotAsyncReady& slot, MountMountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_mount_mountable(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         NULL,
                         NULL,
                         &SignalProxy_async_callback,
                         slot_copy);
}

void File::mount_mountable(MountMountFlags flags)
{
  g_file_mount_mountable(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         NULL,
                         NULL,
                         NULL,
                         NULL);
}

void File::unmount_mountable(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, MountUnmountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_unmount_mountable(gobj(),
                           static_cast<GMountUnmountFlags>(flags), 
                           cancellable->gobj(),
                           &SignalProxy_async_callback,
                           slot_copy);
}

void
File::unmount_mountable(const SlotAsyncReady& slot, MountUnmountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_unmount_mountable(gobj(),
                           static_cast<GMountUnmountFlags>(flags), 
                           NULL,
                           &SignalProxy_async_callback,
                           slot_copy);
}

void
File::unmount_mountable(MountUnmountFlags flags)
{
  g_file_unmount_mountable(gobj(),
                           static_cast<GMountUnmountFlags>(flags), 
                           NULL,
                           NULL,
                           NULL);
}

void File::mount_enclosing_volume(const Glib::RefPtr<MountOperation>& mount_operation, const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, MountMountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_mount_enclosing_volume(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         mount_operation->gobj(),
                         cancellable->gobj(),
                         &SignalProxy_async_callback,
                         slot_copy);
}

void File::mount_enclosing_volume(const Glib::RefPtr<MountOperation>& mount_operation, const SlotAsyncReady& slot, MountMountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_mount_enclosing_volume(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         mount_operation->gobj(),
                         NULL,
                         &SignalProxy_async_callback,
                         slot_copy);
}

void File::mount_enclosing_volume(const SlotAsyncReady& slot, MountMountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_mount_enclosing_volume(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         NULL,
                         NULL,
                         &SignalProxy_async_callback,
                         slot_copy);
}

void File::mount_enclosing_volume(MountMountFlags flags)
{
  g_file_mount_enclosing_volume(gobj(),
                         static_cast<GMountMountFlags>(flags),
                         NULL,
                         NULL,
                         NULL,
                         NULL);
}

void
File::eject_mountable(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, MountUnmountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_eject_mountable(gobj(),
                         static_cast<GMountUnmountFlags>(flags), 
                         cancellable->gobj(),
                         &SignalProxy_async_callback,
                         slot_copy);
}

void
File::eject_mountable(const SlotAsyncReady& slot, MountUnmountFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_eject_mountable(gobj(),
                         static_cast<GMountUnmountFlags>(flags), 
                         NULL,
                         &SignalProxy_async_callback,
                         slot_copy);
}

void
File::eject_mountable(MountUnmountFlags flags)
{
  g_file_eject_mountable(gobj(),
                         static_cast<GMountUnmountFlags>(flags), 
                         NULL,
                         NULL,
                         NULL);
}

void
File::load_contents_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_load_contents_async(gobj(),
                             cancellable->gobj(),
                             &SignalProxy_async_callback,
                             slot_copy);
}

void
File::load_contents_async(const SlotAsyncReady& slot)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_load_contents_async(gobj(),
                             NULL,
                             &SignalProxy_async_callback,
                             slot_copy);
}

void
File::load_partial_contents_async(const SlotReadMore& slot_read_more, const SlotAsyncReady& slot_async_ready, const Glib::RefPtr<Cancellable>& cancellable)
{
  // Create a new pair which will hold copies of passed slots.
  // This will be deleted in the SignalProxy_load_partial_contents_ready_callback() callback
  LoadPartialSlots* slots = new LoadPartialSlots();
  SlotReadMore* slot_read_more_copy = new SlotReadMore(slot_read_more);
  SlotAsyncReady* slot_async_copy = new SlotAsyncReady(slot_async_ready);

  slots->first = slot_read_more_copy;
  slots->second = slot_async_copy;

  g_file_load_partial_contents_async(gobj(),
                                     cancellable->gobj(),
                                     &SignalProxy_load_partial_contents_read_more_callback,
                                     &SignalProxy_load_partial_contents_ready_callback,
                                     slots);
}

void
File::load_partial_contents_async(const SlotReadMore& slot_read_more,
                                  const SlotAsyncReady& slot_async_ready)
{
  // Create a new pair which will hold copies of passed slots.
  // This will be deleted in the SignalProxy_load_partial_contents_ready_callback() callback
  LoadPartialSlots* slots = new LoadPartialSlots();
  SlotReadMore* slot_read_more_copy = new SlotReadMore(slot_read_more);
  SlotAsyncReady* slot_async_copy = new SlotAsyncReady(slot_async_ready);

  slots->first = slot_read_more_copy;
  slots->second = slot_async_copy;

  g_file_load_partial_contents_async(gobj(),
                                     NULL,
                                     &SignalProxy_load_partial_contents_read_more_callback,
                                     &SignalProxy_load_partial_contents_ready_callback,
                                     slots);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void File::replace_contents(const char* contents, gsize length, const std::string& etag, std::string& new_etag, const Glib::RefPtr<Cancellable>& cancellable, bool make_backup, FileCreateFlags flags)
#else
void File::replace_contents(const char* contents, gsize length, const std::string& etag, std::string& new_etag, const Glib::RefPtr<Cancellable>& cancellable, bool make_backup, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* c_etag_new = 0;
  g_file_replace_contents(gobj(), contents, length, etag.empty() ? NULL : etag.c_str(), static_cast<int>(make_backup), ((GFileCreateFlags)(flags)), &c_etag_new, const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  if(c_etag_new)
    new_etag = c_etag_new;
  else
    new_etag = std::string();
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void File::replace_contents(const char* contents, gsize length, const std::string& etag, std::string& new_etag, bool make_backup, FileCreateFlags flags)
#else
void File::replace_contents(const char* contents, gsize length, const std::string& etag, std::string& new_etag, bool make_backup, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* c_etag_new = 0;
  g_file_replace_contents(gobj(), contents, length, etag.empty() ? NULL : etag.c_str(), static_cast<int>(make_backup), ((GFileCreateFlags)(flags)), &c_etag_new, NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  if(c_etag_new)
    new_etag = c_etag_new;
  else
    new_etag = std::string();
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void File::replace_contents(const std::string& contents, const std::string& etag, std::string& new_etag, const Glib::RefPtr<Cancellable>& cancellable, bool make_backup, FileCreateFlags flags)
#else
void File::replace_contents(const std::string& contents, const std::string& etag, std::string& new_etag, const Glib::RefPtr<Cancellable>& cancellable, bool make_backup, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* c_etag_new = 0;
  g_file_replace_contents(gobj(), contents.c_str(), contents.size(), etag.empty() ? NULL : etag.c_str(), static_cast<int>(make_backup), ((GFileCreateFlags)(flags)), &c_etag_new, const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  if(c_etag_new)
    new_etag = c_etag_new;
  else
    new_etag = std::string();
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void File::replace_contents(const std::string& contents, const std::string& etag, std::string& new_etag, bool make_backup, FileCreateFlags flags)
#else
void File::replace_contents(const std::string& contents, const std::string& etag, std::string& new_etag, bool make_backup, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* c_etag_new = 0;
  g_file_replace_contents(gobj(), contents.c_str(), contents.size(), etag.empty() ? NULL : etag.c_str(), static_cast<int>(make_backup), ((GFileCreateFlags)(flags)), &c_etag_new, NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  if(c_etag_new)
    new_etag = c_etag_new;
  else
    new_etag = std::string();
}

void
File::replace_contents_async(const SlotAsyncReady& slot,
                             const Glib::RefPtr<Cancellable>& cancellable,
                             const char* contents,
                             gsize length,
                             const std::string& etag,
                             bool make_backup,
                             FileCreateFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_replace_contents_async(gobj(),
                                contents,
                                length,
                                etag.empty() ? NULL : etag.c_str(),
                                make_backup,
                                static_cast<GFileCreateFlags>(flags),
                                cancellable->gobj(),
                                &SignalProxy_async_callback,
                                slot_copy);
}

void
File::replace_contents_async(const SlotAsyncReady& slot,
                             const char* contents,
                             gsize length,
                             const std::string& etag,
                             bool make_backup,
                             FileCreateFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_replace_contents_async(gobj(),
                                contents,
                                length,
                                etag.empty() ? NULL : etag.c_str(),
                                make_backup,
                                static_cast<GFileCreateFlags>(flags),
                                NULL,
                                &SignalProxy_async_callback,
                                slot_copy);
}

void
File::replace_contents_async(const SlotAsyncReady& slot,
                             const Glib::RefPtr<Cancellable>& cancellable,
                             const std::string& contents,
                             const std::string& etag,
                             bool make_backup,
                             FileCreateFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_replace_contents_async(gobj(),
                                contents.c_str(),
                                contents.size(),
                                etag.empty() ? NULL : etag.c_str(),
                                make_backup,
                                static_cast<GFileCreateFlags>(flags),
                                cancellable->gobj(),
                                &SignalProxy_async_callback,
                                slot_copy);
}

void
File::replace_contents_async(const SlotAsyncReady& slot,
                             const std::string& contents,
                             const std::string& etag,
                             bool make_backup,
                             FileCreateFlags flags)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_replace_contents_async(gobj(),
                                contents.c_str(),
                                contents.size(),
                                etag.empty() ? NULL : etag.c_str(),
                                make_backup,
                                static_cast<GFileCreateFlags>(flags),
                                NULL,
                                &SignalProxy_async_callback,
                                slot_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void File::replace_contents_finish(const Glib::RefPtr<AsyncResult>& result, std::string& new_etag)
#else
void File::replace_contents_finish(const Glib::RefPtr<AsyncResult>& result, std::string& new_etag, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* c_new_etag = 0;
  g_file_replace_contents_finish(gobj(), Glib::unwrap(result), &c_new_etag, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  if(c_new_etag)
    new_etag = c_new_etag;
  else
   new_etag = std::string();
}


#ifdef GLIBMM_EXCEPTIONS_ENABLED
void File::replace_contents_finish(const Glib::RefPtr<AsyncResult>& result)
#else
void File::replace_contents_finish(const Glib::RefPtr<AsyncResult>& result, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  g_file_replace_contents_finish(gobj(), Glib::unwrap(result), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED
}


#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileOutputStream> File::replace(const Glib::RefPtr<Cancellable>& cancellable, const std::string& etag, bool make_backup, FileCreateFlags flags)
#else
Glib::RefPtr<FileOutputStream> File::replace(const Glib::RefPtr<Cancellable>& cancellable, const std::string& etag, bool make_backup, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileOutputStream> retvalue = Glib::wrap(g_file_replace(gobj(), etag.empty() ? NULL : etag.c_str(), static_cast<int>(make_backup), ((GFileCreateFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileOutputStream> File::replace(const std::string& etag, bool make_backup, FileCreateFlags flags)
#else
Glib::RefPtr<FileOutputStream> File::replace(const std::string& etag, bool make_backup, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileOutputStream> retvalue = Glib::wrap(g_file_replace(gobj(), etag.empty() ? NULL : etag.c_str(), static_cast<int>(make_backup), ((GFileCreateFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileMonitor> File::monitor_directory(const Glib::RefPtr<Cancellable>& cancellable, FileMonitorFlags flags)
#else
Glib::RefPtr<FileMonitor> File::monitor_directory(const Glib::RefPtr<Cancellable>& cancellable, FileMonitorFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileMonitor> retvalue = Glib::wrap(g_file_monitor_directory(gobj(), ((GFileMonitorFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileMonitor> File::monitor_directory(FileMonitorFlags flags)
#else
Glib::RefPtr<FileMonitor> File::monitor_directory(FileMonitorFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileMonitor> retvalue = Glib::wrap(g_file_monitor_directory(gobj(), ((GFileMonitorFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileMonitor> File::monitor_file(const Glib::RefPtr<Cancellable>& cancellable, FileMonitorFlags flags)
#else
Glib::RefPtr<FileMonitor> File::monitor_file(const Glib::RefPtr<Cancellable>& cancellable, FileMonitorFlags flags,  std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileMonitor> retvalue = Glib::wrap(g_file_monitor_file(gobj(), ((GFileMonitorFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileMonitor> File::monitor_file(FileMonitorFlags flags)
#else
Glib::RefPtr<FileMonitor> File::monitor_file(FileMonitorFlags flags,  std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileMonitor> retvalue = Glib::wrap(g_file_monitor_file(gobj(), ((GFileMonitorFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}


#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileMonitor> File::monitor(const Glib::RefPtr<Cancellable>& cancellable, FileMonitorFlags flags)
#else
Glib::RefPtr<FileMonitor> File::monitor(const Glib::RefPtr<Cancellable>& cancellable, FileMonitorFlags flags,  std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileMonitor> retvalue = Glib::wrap(g_file_monitor(gobj(), ((GFileMonitorFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileMonitor> File::monitor(FileMonitorFlags flags)
#else
Glib::RefPtr<FileMonitor> File::monitor(FileMonitorFlags flags,  std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileMonitor> retvalue = Glib::wrap(g_file_monitor(gobj(), ((GFileMonitorFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}


#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileInputStream> File::read()
#else
Glib::RefPtr<FileInputStream> File::read(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileInputStream> retvalue = Glib::wrap(g_file_read(gobj(), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

void File::find_enclosing_mount_async(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_find_enclosing_mount_async(gobj(),
                    io_priority,
                    cancellable->gobj(),
                    &SignalProxy_async_callback,
                    slot_copy);
}

void File::find_enclosing_mount_async(const SlotAsyncReady& slot, int io_priority)
{
  // Create a copy of the slot.
  // A pointer to it will be passed through the callback's data parameter
  // and deleted in the callback.
  SlotAsyncReady* slot_copy = new SlotAsyncReady(slot);

  g_file_find_enclosing_mount_async(gobj(),
                    io_priority,
                    NULL,
                    &SignalProxy_async_callback,
                    slot_copy);
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attributes_from_info(const Glib::RefPtr<FileInfo>& info, const Glib::RefPtr<Cancellable>& cancellable, FileQueryInfoFlags flags)
#else
bool File::set_attributes_from_info(const Glib::RefPtr<FileInfo>& info, const Glib::RefPtr<Cancellable>& cancellable, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attributes_from_info(gobj(), Glib::unwrap(info), ((GFileQueryInfoFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::set_attributes_from_info(const Glib::RefPtr<FileInfo>& info, FileQueryInfoFlags flags)
#else
bool File::set_attributes_from_info(const Glib::RefPtr<FileInfo>& info, FileQueryInfoFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_set_attributes_from_info(gobj(), Glib::unwrap(info), ((GFileQueryInfoFlags)(flags)), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::copy_attributes(const Glib::RefPtr<File>& destination, const Glib::RefPtr<Cancellable>& cancellable, FileCopyFlags flags)
#else
bool
File::copy_attributes(const Glib::RefPtr<File>& destination, const Glib::RefPtr<Cancellable>& cancellable, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res;

  res = g_file_copy_attributes(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    cancellable->gobj(),
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool
File::copy_attributes(const Glib::RefPtr<File>& destination, FileCopyFlags flags)
#else
bool
File::copy_attributes(const Glib::RefPtr<File>& destination, FileCopyFlags flags, std::auto_ptr<Glib::Error>& error)
#endif // GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool res;

  res = g_file_copy_attributes(gobj(),
                    destination->gobj(),
                    static_cast<GFileCopyFlags>(flags),
                    NULL,
                    &gerror);

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if (gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if (gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return res;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileOutputStream> File::create_file(const Glib::RefPtr<Cancellable>& cancellable, FileCreateFlags flags)
#else
Glib::RefPtr<FileOutputStream> File::create_file(const Glib::RefPtr<Cancellable>& cancellable, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileOutputStream> retvalue = Glib::wrap(g_file_create(gobj(), ((GFileCreateFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileOutputStream> File::create_file(FileCreateFlags flags)
#else
Glib::RefPtr<FileOutputStream> File::create_file(FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileOutputStream> retvalue = Glib::wrap(g_file_create(gobj(), ((GFileCreateFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::remove()
#else
bool File::remove(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_delete(gobj(), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::trash()
#else
bool File::trash(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_trash(gobj(), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::make_directory()
#else
bool File::make_directory(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_make_directory(gobj(), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::make_symbolic_link(const std::string& symlink_value)
#else
bool File::make_symbolic_link(const std::string& symlink_value, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  bool retvalue = g_file_make_symbolic_link(gobj(), symlink_value.c_str(), NULL, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileAttributeInfoList> File::query_settable_attributes()
#else
Glib::RefPtr<FileAttributeInfoList> File::query_settable_attributes(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileAttributeInfoList> retvalue = Glib::wrap(g_file_query_settable_attributes(gobj(), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileAttributeInfoList> File::query_writable_namespaces()
#else
Glib::RefPtr<FileAttributeInfoList> File::query_writable_namespaces(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileAttributeInfoList> retvalue = Glib::wrap(g_file_query_writable_namespaces(gobj(), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}


#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileOutputStream> File::append_to(const Glib::RefPtr<Cancellable>& cancellable, FileCreateFlags flags)
#else
Glib::RefPtr<FileOutputStream> File::append_to(const Glib::RefPtr<Cancellable>& cancellable, FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileOutputStream> retvalue = Glib::wrap(g_file_append_to(gobj(), ((GFileCreateFlags)(flags)), const_cast<GCancellable*>(Glib::unwrap(cancellable)), &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<FileOutputStream> File::append_to(FileCreateFlags flags)
#else
Glib::RefPtr<FileOutputStream> File::append_to(FileCreateFlags flags, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<FileOutputStream> retvalue = Glib::wrap(g_file_append_to(gobj(), ((GFileCreateFlags)(flags)), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<Mount> File::find_enclosing_mount()
#else
Glib::RefPtr<Mount> File::find_enclosing_mount(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<Mount> retvalue = Glib::wrap(g_file_find_enclosing_mount(gobj(), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
Glib::RefPtr<AppInfo> File::query_default_handler()
#else
Glib::RefPtr<AppInfo> File::query_default_handler(std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  Glib::RefPtr<AppInfo> retvalue = Glib::wrap(g_file_query_default_handler(gobj(), NULL, &(gerror)));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::load_contents(const Glib::RefPtr<Cancellable>& cancellable, char*& contents, gsize& length, std::string& etag_out)
#else
bool File::load_contents(const Glib::RefPtr<Cancellable>& cancellable, char*& contents, gsize& length, std::string& etag_out, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* cetag_out = 0;
  bool retvalue = g_file_load_contents(gobj(), Glib::unwrap(cancellable), &contents, &(length), &cetag_out, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  etag_out = Glib::convert_return_gchar_ptr_to_stdstring(cetag_out);

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::load_contents(char*& contents, gsize& length, std::string& etag_out)
#else
bool File::load_contents(char*& contents, gsize& length, std::string& etag_out, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* cetag_out = 0;
  bool retvalue = g_file_load_contents(gobj(), NULL, &contents, &(length), &cetag_out, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  etag_out = Glib::convert_return_gchar_ptr_to_stdstring(cetag_out);

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::load_contents_finish(const Glib::RefPtr<AsyncResult>& result, char*& contents, gsize& length, std::string& etag_out)
#else
bool File::load_contents_finish(const Glib::RefPtr<AsyncResult>& result, char*& contents, gsize& length, std::string& etag_out, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* cetag_out = 0;
  bool retvalue = g_file_load_contents_finish(gobj(), Glib::unwrap(result), &contents, &(length), &cetag_out, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  etag_out = Glib::convert_return_gchar_ptr_to_stdstring(cetag_out);

  return retvalue;
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
bool File::load_partial_contents_finish(const Glib::RefPtr<AsyncResult>& result, char*& contents, gsize& length, std::string& etag_out)
#else
bool File::load_partial_contents_finish(const Glib::RefPtr<AsyncResult>& result, char*& contents, gsize& length, std::string& etag_out, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  gchar* cetag_out = 0;
  bool retvalue = g_file_load_partial_contents_finish(gobj(), Glib::unwrap(result), &contents, &(length), &cetag_out, &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED

  etag_out = Glib::convert_return_gchar_ptr_to_stdstring(cetag_out);

  return retvalue;
}

} // namespace Gio
