// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GDKMM_CURSOR_H
#define _GDKMM_CURSOR_H

#include <glibmm.h>

/* $Id$ */

/* drawable.h
 *
 * Copyright (C) 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gdkmm/color.h>
#include <gdkmm/bitmap.h>
#include <gdkmm/display.h>
#include <gdkmm/pixbuf.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
extern "C" { typedef struct _GdkCursor GdkCursor; }
#endif

namespace Gdk
{


/** @addtogroup gdkmmEnums Enums and Flags */

/**
 * @ingroup gdkmmEnums
 */
enum CursorType
{
  X_CURSOR = 0,
  ARROW = 2,
  BASED_ARROW_DOWN = 4,
  BASED_ARROW_UP = 6,
  BOAT = 8,
  BOGOSITY = 10,
  BOTTOM_LEFT_CORNER = 12,
  BOTTOM_RIGHT_CORNER = 14,
  BOTTOM_SIDE = 16,
  BOTTOM_TEE = 18,
  BOX_SPIRAL = 20,
  CENTER_PTR = 22,
  CIRCLE = 24,
  CLOCK = 26,
  COFFEE_MUG = 28,
  CROSS = 30,
  CROSS_REVERSE = 32,
  CROSSHAIR = 34,
  DIAMOND_CROSS = 36,
  DOT = 38,
  DOTBOX = 40,
  DOUBLE_ARROW = 42,
  DRAFT_LARGE = 44,
  DRAFT_SMALL = 46,
  DRAPED_BOX = 48,
  EXCHANGE = 50,
  FLEUR = 52,
  GOBBLER = 54,
  GUMBY = 56,
  HAND1 = 58,
  HAND2 = 60,
  HEART = 62,
  ICON = 64,
  IRON_CROSS = 66,
  LEFT_PTR = 68,
  LEFT_SIDE = 70,
  LEFT_TEE = 72,
  LEFTBUTTON = 74,
  LL_ANGLE = 76,
  LR_ANGLE = 78,
  MAN = 80,
  MIDDLEBUTTON = 82,
  MOUSE = 84,
  PENCIL = 86,
  PIRATE = 88,
  PLUS = 90,
  QUESTION_ARROW = 92,
  RIGHT_PTR = 94,
  RIGHT_SIDE = 96,
  RIGHT_TEE = 98,
  RIGHTBUTTON = 100,
  RTL_LOGO = 102,
  SAILBOAT = 104,
  SB_DOWN_ARROW = 106,
  SB_H_DOUBLE_ARROW = 108,
  SB_LEFT_ARROW = 110,
  SB_RIGHT_ARROW = 112,
  SB_UP_ARROW = 114,
  SB_V_DOUBLE_ARROW = 116,
  SHUTTLE = 118,
  SIZING = 120,
  SPIDER = 122,
  SPRAYCAN = 124,
  STAR = 126,
  TARGET = 128,
  TCROSS = 130,
  TOP_LEFT_ARROW = 132,
  TOP_LEFT_CORNER = 134,
  TOP_RIGHT_CORNER = 136,
  TOP_SIDE = 138,
  TOP_TEE = 140,
  TREK = 142,
  UL_ANGLE = 144,
  UMBRELLA = 146,
  UR_ANGLE = 148,
  WATCH = 150,
  XTERM = 152,
  LAST_CURSOR = 153,
  CURSOR_IS_PIXMAP = -1
};

} // namespace Gdk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gdk::CursorType> : public Glib::Value_Enum<Gdk::CursorType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gdk
{


/** This represents a cursor.
 */
class Cursor
{
  public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef Cursor CppObjectType;
  typedef GdkCursor BaseObjectType;

  static GType get_type() G_GNUC_CONST;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

  Cursor();

  explicit Cursor(GdkCursor* gobject, bool make_a_copy = true);

  Cursor(const Cursor& other);
  Cursor& operator=(const Cursor& other);

  ~Cursor();

  void swap(Cursor& other);

  ///Provides access to the underlying C instance.
  GdkCursor*       gobj()       { return gobject_; }

  ///Provides access to the underlying C instance.
  const GdkCursor* gobj() const { return gobject_; }

  ///Provides access to the underlying C instance. The caller is responsible for freeing it. Use when directly setting fields in structs.
  GdkCursor* gobj_copy() const;

protected:
  GdkCursor* gobject_;

private:

  
public:
  explicit Cursor(CursorType cursor_type);
  Cursor(const Glib::RefPtr<Pixmap>& source, const Glib::RefPtr<Pixmap>& mask,
         const Color& fg, const Color& bg,
         int x, int y);
  explicit Cursor(const Glib::RefPtr<Display>& display, CursorType cursor_type);
  Cursor(const Glib::RefPtr<Display>& display, const Glib::RefPtr<Pixbuf>& pixbuf, int x, int y);

  
  /** Returns the display on which the Gdk::Cursor is defined.
   * @return The Gdk::Display associated to @a cursor 
   * 
   * Since: 2.2.
   */
  Glib::RefPtr<Display> get_display();
  
  /** Returns the display on which the Gdk::Cursor is defined.
   * @return The Gdk::Display associated to @a cursor 
   * 
   * Since: 2.2.
   */
  Glib::RefPtr<const Display> get_display() const;


};

} //namespace Gdk


namespace Gdk
{

/** @relates Gdk::Cursor
 * @param lhs The left-hand side
 * @param rhs The right-hand side
 */
inline void swap(Cursor& lhs, Cursor& rhs)
  { lhs.swap(rhs); }

} // namespace Gdk

namespace Glib
{

/** @relates Gdk::Cursor
 * @param object The C instance
 * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
 * @result A C++ instance that wraps this C instance.
 */
Gdk::Cursor wrap(GdkCursor* object, bool take_copy = false);

#ifndef DOXYGEN_SHOULD_SKIP_THIS
template <>
class Value<Gdk::Cursor> : public Glib::Value_Boxed<Gdk::Cursor>
{};
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} // namespace Glib

#endif /* _GDKMM_CURSOR_H */

