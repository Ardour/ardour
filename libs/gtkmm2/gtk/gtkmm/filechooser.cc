// Generated by gtkmmproc -- DO NOT MODIFY!

#include <gtkmm/filechooser.h>
#include <gtkmm/private/filechooser_p.h>

// -*- c++ -*-
/* $Id$ */

/* Copyright 2003 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtk/gtkfilechooser.h>
//#include <gtk/gtkfilesystem.h> //We include this semi-private header just to get GTK_FILE_SYSTEM_ERROR.


namespace
{

const Glib::SignalProxyInfo FileChooser_signal_current_folder_changed_info =
{
  "current_folder_changed",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo FileChooser_signal_selection_changed_info =
{
  "selection_changed",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo FileChooser_signal_update_preview_info =
{
  "update_preview",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo FileChooser_signal_file_activated_info =
{
  "file_activated",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};

} // anonymous namespace

// static
GType Glib::Value<Gtk::FileChooserAction>::value_type()
{
  return gtk_file_chooser_action_get_type();
}


Gtk::FileChooserError::FileChooserError(Gtk::FileChooserError::Code error_code, const Glib::ustring& error_message)
:
  Glib::Error (GTK_FILE_CHOOSER_ERROR, error_code, error_message)
{}

Gtk::FileChooserError::FileChooserError(GError* gobject)
:
  Glib::Error (gobject)
{}

Gtk::FileChooserError::Code Gtk::FileChooserError::code() const
{
  return static_cast<Code>(Glib::Error::code());
}

void Gtk::FileChooserError::throw_func(GError* gobject)
{
  throw Gtk::FileChooserError(gobject);
}

// static
GType Glib::Value<Gtk::FileChooserError::Code>::value_type()
{
  return gtk_file_chooser_error_get_type();
}


namespace Glib
{

Glib::RefPtr<Gtk::FileChooser> wrap(GtkFileChooser* object, bool take_copy)
{
  return Glib::RefPtr<Gtk::FileChooser>( dynamic_cast<Gtk::FileChooser*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} // namespace Glib


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Interface_Class& FileChooser_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Interface_Class has to know the interface init function
    // in order to add interfaces to implementing types.
    class_init_func_ = &FileChooser_Class::iface_init_function;

    // We can not derive from another interface, and it is not necessary anyway.
    gtype_ = gtk_file_chooser_get_type();
  }

  return *this;
}

void FileChooser_Class::iface_init_function(void* g_iface, void*)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_iface);

  //This is just to avoid an "unused variable" warning when there are no vfuncs or signal handlers to connect.
  //This is a temporary fix until I find out why I can not seem to derive a GtkFileChooser interface. murrayc
  g_assert(klass != 0); 

}


Glib::ObjectBase* FileChooser_Class::wrap_new(GObject* object)
{
  return new FileChooser((GtkFileChooser*)(object));
}


/* The implementation: */

FileChooser::FileChooser()
:
  Glib::Interface(filechooser_class_.init())
{}

FileChooser::FileChooser(GtkFileChooser* castitem)
:
  Glib::Interface((GObject*)(castitem))
{}

FileChooser::~FileChooser()
{}

// static
void FileChooser::add_interface(GType gtype_implementer)
{
  filechooser_class_.init().add_interface(gtype_implementer);
}

FileChooser::CppClassType FileChooser::filechooser_class_; // initialize static member

GType FileChooser::get_type()
{
  return filechooser_class_.init().get_type();
}

GType FileChooser::get_base_type()
{
  return gtk_file_chooser_get_type();
}


void FileChooser::set_action(FileChooserAction action)
{
  gtk_file_chooser_set_action(gobj(), ((GtkFileChooserAction)(action)));
}

FileChooserAction FileChooser::get_action() const
{
  return ((FileChooserAction)(gtk_file_chooser_get_action(const_cast<GtkFileChooser*>(gobj()))));
}

void FileChooser::set_local_only(bool local_only)
{
  gtk_file_chooser_set_local_only(gobj(), static_cast<int>(local_only));
}

bool FileChooser::get_local_only() const
{
  return gtk_file_chooser_get_local_only(const_cast<GtkFileChooser*>(gobj()));
}

void FileChooser::set_select_multiple(bool select_multiple)
{
  gtk_file_chooser_set_select_multiple(gobj(), static_cast<int>(select_multiple));
}

bool FileChooser::get_select_multiple() const
{
  return gtk_file_chooser_get_select_multiple(const_cast<GtkFileChooser*>(gobj()));
}

void FileChooser::set_show_hidden(bool show_hidden)
{
  gtk_file_chooser_set_show_hidden(gobj(), static_cast<int>(show_hidden));
}

bool FileChooser::get_show_hidden() const
{
  return gtk_file_chooser_get_show_hidden(const_cast<GtkFileChooser*>(gobj()));
}

void FileChooser::set_current_name(const Glib::ustring& name)
{
  gtk_file_chooser_set_current_name(gobj(), name.c_str());
}

Glib::ustring FileChooser::get_filename() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_file_chooser_get_filename(const_cast<GtkFileChooser*>(gobj())));
}

bool FileChooser::set_filename(const Glib::ustring& filename)
{
  return gtk_file_chooser_set_filename(gobj(), filename.c_str());
}

bool FileChooser::select_filename(const Glib::ustring& filename)
{
  return gtk_file_chooser_select_filename(gobj(), filename.c_str());
}

void FileChooser::unselect_filename(const Glib::ustring& filename)
{
  gtk_file_chooser_unselect_filename(gobj(), filename.c_str());
}

void FileChooser::select_all()
{
  gtk_file_chooser_select_all(gobj());
}

void FileChooser::unselect_all()
{
  gtk_file_chooser_unselect_all(gobj());
}

Glib::SListHandle<Glib::ustring> FileChooser::get_filenames() const
{
  return Glib::SListHandle<Glib::ustring>(gtk_file_chooser_get_filenames(const_cast<GtkFileChooser*>(gobj())), Glib::OWNERSHIP_DEEP);
}

bool FileChooser::set_current_folder(const Glib::ustring& filename)
{
  return gtk_file_chooser_set_current_folder(gobj(), filename.c_str());
}

Glib::ustring FileChooser::get_current_folder() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_file_chooser_get_current_folder(const_cast<GtkFileChooser*>(gobj())));
}

Glib::ustring FileChooser::get_uri() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_file_chooser_get_uri(const_cast<GtkFileChooser*>(gobj())));
}

bool FileChooser::set_uri(const Glib::ustring& uri)
{
  return gtk_file_chooser_set_uri(gobj(), uri.c_str());
}

bool FileChooser::select_uri(const Glib::ustring& uri)
{
  return gtk_file_chooser_select_uri(gobj(), uri.c_str());
}

void FileChooser::unselect_uri(const Glib::ustring& uri)
{
  gtk_file_chooser_unselect_uri(gobj(), uri.c_str());
}

Glib::SListHandle<Glib::ustring> FileChooser::get_uris() const
{
  return Glib::SListHandle<Glib::ustring>(gtk_file_chooser_get_uris(const_cast<GtkFileChooser*>(gobj())), Glib::OWNERSHIP_DEEP);
}

bool FileChooser::set_current_folder_uri(const Glib::ustring& uri)
{
  return gtk_file_chooser_set_current_folder_uri(gobj(), uri.c_str());
}

Glib::ustring FileChooser::get_current_folder_uri() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_file_chooser_get_current_folder_uri(const_cast<GtkFileChooser*>(gobj())));
}

void FileChooser::set_preview_widget(Gtk::Widget& preview_widget)
{
  gtk_file_chooser_set_preview_widget(gobj(), (preview_widget).gobj());
}

const Gtk::Widget* FileChooser::get_preview_widget() const
{
  return Glib::wrap(gtk_file_chooser_get_preview_widget(const_cast<GtkFileChooser*>(gobj())));
}

Gtk::Widget* FileChooser::get_preview_widget()
{
  return Glib::wrap(gtk_file_chooser_get_preview_widget(gobj()));
}

void FileChooser::set_preview_widget_active(bool active)
{
  gtk_file_chooser_set_preview_widget_active(gobj(), static_cast<int>(active));
}

bool FileChooser::get_preview_widget_active() const
{
  return gtk_file_chooser_get_preview_widget_active(const_cast<GtkFileChooser*>(gobj()));
}

void FileChooser::set_use_preview_label(bool use_label)
{
  gtk_file_chooser_set_use_preview_label(gobj(), static_cast<int>(use_label));
}

bool FileChooser::get_use_preview_label() const
{
  return gtk_file_chooser_get_use_preview_label(const_cast<GtkFileChooser*>(gobj()));
}

Glib::ustring FileChooser::get_preview_filename() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_file_chooser_get_preview_filename(const_cast<GtkFileChooser*>(gobj())));
}

Glib::ustring FileChooser::get_preview_uri() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_file_chooser_get_preview_uri(const_cast<GtkFileChooser*>(gobj())));
}

void FileChooser::set_extra_widget(Gtk::Widget& extra_widget)
{
  gtk_file_chooser_set_extra_widget(gobj(), (extra_widget).gobj());
}

Gtk::Widget* FileChooser::get_extra_widget()
{
  return Glib::wrap(gtk_file_chooser_get_extra_widget(gobj()));
}

const Gtk::Widget* FileChooser::get_extra_widget() const
{
  return Glib::wrap(gtk_file_chooser_get_extra_widget(const_cast<GtkFileChooser*>(gobj())));
}

void FileChooser::add_filter(const FileFilter& filter)
{
  gtk_file_chooser_add_filter(gobj(), const_cast<GtkFileFilter*>((filter).gobj()));
}

void FileChooser::remove_filter(const FileFilter& filter)
{
  gtk_file_chooser_remove_filter(gobj(), const_cast<GtkFileFilter*>((filter).gobj()));
}

Glib::SListHandle< FileFilter* > FileChooser::list_filters()
{
  return Glib::SListHandle< FileFilter* >(gtk_file_chooser_list_filters(gobj()), Glib::OWNERSHIP_SHALLOW);
}

Glib::SListHandle< const FileFilter* > FileChooser::list_filters() const
{
  return Glib::SListHandle< const FileFilter* >(gtk_file_chooser_list_filters(const_cast<GtkFileChooser*>(gobj())), Glib::OWNERSHIP_SHALLOW);
}

void FileChooser::set_filter(const FileFilter& filter)
{
  gtk_file_chooser_set_filter(gobj(), const_cast<GtkFileFilter*>((filter).gobj()));
}

FileFilter* FileChooser::get_filter()
{

  FileFilter* retvalue = Glib::wrap(gtk_file_chooser_get_filter(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

const FileFilter* FileChooser::get_filter() const
{

  const FileFilter* retvalue = Glib::wrap(gtk_file_chooser_get_filter(const_cast<GtkFileChooser*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

bool FileChooser::add_shortcut_folder(const Glib::ustring& folder)
{
  GError *error = 0;
  bool retvalue = gtk_file_chooser_add_shortcut_folder(gobj(), folder.c_str(), &(error));
  if(error) ::Glib::Error::throw_exception(error);
  return retvalue;
}

bool FileChooser::remove_shortcut_folder(const Glib::ustring& folder)
{
  GError *error = 0;
  bool retvalue = gtk_file_chooser_remove_shortcut_folder(gobj(), folder.c_str(), &(error));
  if(error) ::Glib::Error::throw_exception(error);
  return retvalue;
}

Glib::SListHandle<Glib::ustring> FileChooser::list_shortcut_folders() const
{
  return Glib::SListHandle<Glib::ustring>(gtk_file_chooser_list_shortcut_folders(const_cast<GtkFileChooser*>(gobj())), Glib::OWNERSHIP_DEEP);
}

bool FileChooser::add_shortcut_folder_uri(const Glib::ustring& uri)
{
  GError *error = 0;
  bool retvalue = gtk_file_chooser_add_shortcut_folder_uri(gobj(), uri.c_str(), &(error));
  if(error) ::Glib::Error::throw_exception(error);
  return retvalue;
}

bool FileChooser::remove_shortcut_folder_uri(const Glib::ustring& uri)
{
  GError *error = 0;
  bool retvalue = gtk_file_chooser_remove_shortcut_folder_uri(gobj(), uri.c_str(), &(error));
  if(error) ::Glib::Error::throw_exception(error);
  return retvalue;
}

Glib::SListHandle<Glib::ustring> FileChooser::list_shortcut_folder_uris() const
{
  return Glib::SListHandle<Glib::ustring>(gtk_file_chooser_list_shortcut_folder_uris(const_cast<GtkFileChooser*>(gobj())), Glib::OWNERSHIP_DEEP);
}


Glib::SignalProxy0< void > FileChooser::signal_current_folder_changed()
{
  return Glib::SignalProxy0< void >(this, &FileChooser_signal_current_folder_changed_info);
}

Glib::SignalProxy0< void > FileChooser::signal_selection_changed()
{
  return Glib::SignalProxy0< void >(this, &FileChooser_signal_selection_changed_info);
}

Glib::SignalProxy0< void > FileChooser::signal_update_preview()
{
  return Glib::SignalProxy0< void >(this, &FileChooser_signal_update_preview_info);
}

Glib::SignalProxy0< void > FileChooser::signal_file_activated()
{
  return Glib::SignalProxy0< void >(this, &FileChooser_signal_file_activated_info);
}


Glib::PropertyProxy<FileChooserAction> FileChooser::property_action() 
{
  return Glib::PropertyProxy<FileChooserAction>(this, "action");
}

Glib::PropertyProxy_ReadOnly<FileChooserAction> FileChooser::property_action() const
{
  return Glib::PropertyProxy_ReadOnly<FileChooserAction>(this, "action");
}

Glib::PropertyProxy<FileFilter*> FileChooser::property_filter() 
{
  return Glib::PropertyProxy<FileFilter*>(this, "filter");
}

Glib::PropertyProxy_ReadOnly<FileFilter*> FileChooser::property_filter() const
{
  return Glib::PropertyProxy_ReadOnly<FileFilter*>(this, "filter");
}

Glib::PropertyProxy<bool> FileChooser::property_folder_mode() 
{
  return Glib::PropertyProxy<bool>(this, "folder-mode");
}

Glib::PropertyProxy_ReadOnly<bool> FileChooser::property_folder_mode() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "folder-mode");
}

Glib::PropertyProxy<bool> FileChooser::property_local_only() 
{
  return Glib::PropertyProxy<bool>(this, "local-only");
}

Glib::PropertyProxy_ReadOnly<bool> FileChooser::property_local_only() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "local-only");
}

Glib::PropertyProxy<Widget*> FileChooser::property_preview_widget() 
{
  return Glib::PropertyProxy<Widget*>(this, "preview-widget");
}

Glib::PropertyProxy_ReadOnly<Widget*> FileChooser::property_preview_widget() const
{
  return Glib::PropertyProxy_ReadOnly<Widget*>(this, "preview-widget");
}

Glib::PropertyProxy<bool> FileChooser::property_preview_widget_active() 
{
  return Glib::PropertyProxy<bool>(this, "preview-widget-active");
}

Glib::PropertyProxy_ReadOnly<bool> FileChooser::property_preview_widget_active() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "preview-widget-active");
}

Glib::PropertyProxy<bool> FileChooser::property_use_preview_label() 
{
  return Glib::PropertyProxy<bool>(this, "use-preview-label");
}

Glib::PropertyProxy_ReadOnly<bool> FileChooser::property_use_preview_label() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "use-preview-label");
}

Glib::PropertyProxy<Widget*> FileChooser::property_extra_widget() 
{
  return Glib::PropertyProxy<Widget*>(this, "extra-widget");
}

Glib::PropertyProxy_ReadOnly<Widget*> FileChooser::property_extra_widget() const
{
  return Glib::PropertyProxy_ReadOnly<Widget*>(this, "extra-widget");
}

Glib::PropertyProxy<bool> FileChooser::property_select_multiple() 
{
  return Glib::PropertyProxy<bool>(this, "select-multiple");
}

Glib::PropertyProxy_ReadOnly<bool> FileChooser::property_select_multiple() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "select-multiple");
}

Glib::PropertyProxy<bool> FileChooser::property_show_hidden() 
{
  return Glib::PropertyProxy<bool>(this, "show-hidden");
}

Glib::PropertyProxy_ReadOnly<bool> FileChooser::property_show_hidden() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "show-hidden");
}


} // namespace Gtk


