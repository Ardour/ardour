// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GTKMM_FIXED_H
#define _GTKMM_FIXED_H

#include <glibmm.h>

/* $Id$ */

/* fixed.h
 * 
 * Copyright (C) 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/container.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GtkFixed GtkFixed;
typedef struct _GtkFixedClass GtkFixedClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gtk
{ class Fixed_Class; } // namespace Gtk
namespace Gtk
{

/** A container which allows you to position widgets at fixed coordinates.
 *
 * The Gtk::Fixed widget is a container which can place child widgets at fixed positions and with fixed sizes, given in pixels. It performs no automatic layout management.
 * For most applications, you should not use this container, because it will result in truncated text, overlapping widgets, and other display bugs:
 * - Themes may change widget sizes.
 * - Fonts other than the one you used to write the app will of course change the size of widgets containing text; keep in mind that users may use a larger font because of difficulty reading the default, or they may be using Windows or the framebuffer port of GTK+, where different fonts are available.
 * - Translation of text into other languages changes its size. Also, display of non-English text will use a different font in many cases.
 * In addition, the fixed widget can't properly be mirrored in right-to-left languages such as Hebrew and Arabic. i.e. normally GTK+ will flip the interface to put labels to the right of the thing they label, but it can't do that with Gtk::Fixed. So your application will not be usable in right-to-left languages.
 * Finally, fixed positioning makes it kind of annoying to add/remove GUI elements, since you have to reposition all the other elements. This is a long-term maintenance problem for your application.
 * If you know none of these things are an issue for your application, and prefer the simplicity of Gtk::Fixed, by all means use the widget. But you should be aware of the tradeoffs.
 *
 * @ingroup Widgets
 * @ingroup Containers
 */

class Fixed : public Container
{
  public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef Fixed CppObjectType;
  typedef Fixed_Class CppClassType;
  typedef GtkFixed BaseObjectType;
  typedef GtkFixedClass BaseClassType;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

  virtual ~Fixed();

#ifndef DOXYGEN_SHOULD_SKIP_THIS

private:
  friend class Fixed_Class;
  static CppClassType fixed_class_;

  // noncopyable
  Fixed(const Fixed&);
  Fixed& operator=(const Fixed&);

protected:
  explicit Fixed(const Glib::ConstructParams& construct_params);
  explicit Fixed(GtkFixed* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  static GType get_type()      G_GNUC_CONST;
  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GtkObject.
  GtkFixed*       gobj()       { return reinterpret_cast<GtkFixed*>(gobject_); }

  ///Provides access to the underlying C GtkObject.
  const GtkFixed* gobj() const { return reinterpret_cast<GtkFixed*>(gobject_); }


public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


private:

public:
  Fixed();

  
  void put(Widget& widget, int x, int y);
  
  void move(Widget& widget, int x, int y);
  
  /** Sets whether a Gtk::Fixed widget is created with a separate
   * Gdk::Window for widget->window or not. (By default, it will be
   * created with no separate Gdk::Window). This function must be called
   * while the Gtk::Fixed is not realized, for instance, immediately after the
   * window is created.
   * @param has_window <tt>true</tt> if a separate window should be created.
   */
  void set_has_window(bool has_window = true);
  
  /** Gets whether the Gtk::Fixed has its own Gdk::Window.
   * See gdk_fixed_set_has_window().
   * @return <tt>true</tt> if @a fixed  has its own window.
   */
  bool get_has_window() const;


};

} /* namespace Gtk */


namespace Glib
{
  /** @relates Gtk::Fixed
   * @param object The C instance
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   */
  Gtk::Fixed* wrap(GtkFixed* object, bool take_copy = false);
}
#endif /* _GTKMM_FIXED_H */

