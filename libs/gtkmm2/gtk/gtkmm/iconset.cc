// Generated by gtkmmproc -- DO NOT MODIFY!

#include <gtkmm/iconset.h>
#include <gtkmm/private/iconset_p.h>

// -*- c++ -*-
/* $Id$ */

/*
 *
 * Copyright 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/widget.h>
#include <gtkmm/style.h>
#include <gtk/gtkiconfactory.h>

namespace Gtk
{

IconSet::IconSet(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf)
{
  gobject_ = gtk_icon_set_new_from_pixbuf(pixbuf->gobj());
}

Glib::ArrayHandle<IconSize> IconSet::get_sizes() const
{
  GtkIconSize* pSizes = 0;
  int n_sizes = 0;
  gtk_icon_set_get_sizes(const_cast<GtkIconSet*>(gobj()), &pSizes, &n_sizes);

  return Glib::ArrayHandle<IconSize>((IconSize*) pSizes, n_sizes, Glib::OWNERSHIP_SHALLOW);
}

IconSet IconSet::lookup_default(const Gtk::StockID& stock_id) //static
{
  GtkIconSet* pIconSet = gtk_icon_factory_lookup_default(stock_id.get_string().c_str());
  return IconSet(pIconSet, true); //true = take_copy.
}

} /* namespace Gtk */


namespace
{
} // anonymous namespace


namespace Glib
{

Gtk::IconSet wrap(GtkIconSet* object, bool take_copy)
{
  return Gtk::IconSet(object, take_copy);
}

} // namespace Glib


namespace Gtk
{


// static
GType IconSet::get_type()
{
  return gtk_icon_set_get_type();
}

IconSet::IconSet()
:
  gobject_ (gtk_icon_set_new())
{}

IconSet::IconSet(const IconSet& other)
:
  gobject_ ((other.gobject_) ? gtk_icon_set_ref(other.gobject_) : 0)
{}

IconSet::IconSet(GtkIconSet* gobject, bool make_a_copy)
:
  // For BoxedType wrappers, make_a_copy is true by default.  The static
  // BoxedType wrappers must always take a copy, thus make_a_copy = true
  // ensures identical behaviour if the default argument is used.
  gobject_ ((make_a_copy && gobject) ? gtk_icon_set_ref(gobject) : gobject)
{}

IconSet& IconSet::operator=(const IconSet& other)
{
  IconSet temp (other);
  swap(temp);
  return *this;
}

IconSet::~IconSet()
{
  if(gobject_)
    gtk_icon_set_unref(gobject_);
}

void IconSet::swap(IconSet& other)
{
  GtkIconSet *const temp = gobject_;
  gobject_ = other.gobject_;
  other.gobject_ = temp;
}

GtkIconSet* IconSet::gobj_copy() const
{
  return gtk_icon_set_ref(gobject_);
}


IconSet IconSet::copy() const
{
  return Glib::wrap(gtk_icon_set_copy(const_cast<GtkIconSet*>(gobj())));
}

Glib::RefPtr<Gdk::Pixbuf> IconSet::render_icon(const Glib::RefPtr<Style>& style, TextDirection direction, Gtk::StateType state, IconSize size, Widget& widget, const Glib::ustring& detail)
{
  return Glib::wrap(gtk_icon_set_render_icon(gobj(), Glib::unwrap(style), ((GtkTextDirection)(direction)), ((GtkStateType)(state)), static_cast<GtkIconSize>(int(size)), (widget).gobj(), detail.c_str()));
}

void IconSet::add_source(const IconSource& source)
{
  gtk_icon_set_add_source(gobj(), (source).gobj());
}


} // namespace Gtk


