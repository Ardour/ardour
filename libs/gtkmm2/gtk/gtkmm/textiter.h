// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GTKMM_TEXTITER_H
#define _GTKMM_TEXTITER_H


#include <glibmm.h>

/* $Id$ */

/* Copyright(C) 1998-2002 The gtkmm Development Team
 *
 * This library is free software, ) you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation, ) either
 * version 2 of the License, or(at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, ) without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library, ) if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/exceptionhandler.h>
#include <glibmm/slisthandle.h>
#include <gdkmm/pixbuf.h>
#include <gtkmm/texttag.h>
#include <gtkmm/textchildanchor.h>
#include <gtkmm/textattributes.h>
#include <gtk/gtktextiter.h> /* we need the definition of GtkTextIter */


namespace Gtk
{


/** @addtogroup gtkmmEnums Enums and Flags */

/**
 * @ingroup gtkmmEnums
 * @par Bitwise operators:
 * <tt>%TextSearchFlags operator|(TextSearchFlags, TextSearchFlags)</tt><br>
 * <tt>%TextSearchFlags operator&(TextSearchFlags, TextSearchFlags)</tt><br>
 * <tt>%TextSearchFlags operator^(TextSearchFlags, TextSearchFlags)</tt><br>
 * <tt>%TextSearchFlags operator~(TextSearchFlags)</tt><br>
 * <tt>%TextSearchFlags& operator|=(TextSearchFlags&, TextSearchFlags)</tt><br>
 * <tt>%TextSearchFlags& operator&=(TextSearchFlags&, TextSearchFlags)</tt><br>
 * <tt>%TextSearchFlags& operator^=(TextSearchFlags&, TextSearchFlags)</tt><br>
 */
enum TextSearchFlags
{
  TEXT_SEARCH_VISIBLE_ONLY = 1 << 0,
  TEXT_SEARCH_TEXT_ONLY = 1 << 1
};

/** @ingroup gtkmmEnums */
inline TextSearchFlags operator|(TextSearchFlags lhs, TextSearchFlags rhs)
  { return static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline TextSearchFlags operator&(TextSearchFlags lhs, TextSearchFlags rhs)
  { return static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline TextSearchFlags operator^(TextSearchFlags lhs, TextSearchFlags rhs)
  { return static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gtkmmEnums */
inline TextSearchFlags operator~(TextSearchFlags flags)
  { return static_cast<TextSearchFlags>(~static_cast<unsigned>(flags)); }

/** @ingroup gtkmmEnums */
inline TextSearchFlags& operator|=(TextSearchFlags& lhs, TextSearchFlags rhs)
  { return (lhs = static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gtkmmEnums */
inline TextSearchFlags& operator&=(TextSearchFlags& lhs, TextSearchFlags rhs)
  { return (lhs = static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gtkmmEnums */
inline TextSearchFlags& operator^=(TextSearchFlags& lhs, TextSearchFlags rhs)
  { return (lhs = static_cast<TextSearchFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace Gtk


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gtk::TextSearchFlags> : public Glib::Value_Flags<Gtk::TextSearchFlags>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gtk
{


class TextBuffer;
class TextMark;

//TODO: Maybe we should have separate iterators for words, lines, and sentences.
/** Typefed as Gtk::TextBuffer::iterator.
 * An iterator represents a position between two characters in the text buffer. Iterators are not valid indefinitely; whenever the buffer is
 * modified in a way that affects the number of characters in the buffer, all outstanding iterators become invalid. (Note that
 * deleting 5 characters and then reinserting 5 still invalidates iterators, though you end up with the same number of characters
 * you pass through a state with a different number).
 *
 * Because of this, iterators can't be used to preserve positions across buffer modifications. To preserve a position, the
 * @link Gtk::TextMark Gtk::TextBuffer::Mark@endlink object is ideal.
 *
 * You can iterate over characters, words, lines, and sentences,
 * but operator*() and operator++() deal only in characters.
 * 
 * @ingroup TextView
 */
class TextIter
{
  public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef TextIter CppObjectType;
  typedef GtkTextIter BaseObjectType;

  static GType get_type() G_GNUC_CONST;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

  TextIter();

  explicit TextIter(const GtkTextIter* gobject); // always takes a copy

  ///Provides access to the underlying C instance.
  GtkTextIter*       gobj()       { return &gobject_; }

  ///Provides access to the underlying C instance.
  const GtkTextIter* gobj() const { return &gobject_; }

protected:
  GtkTextIter gobject_;

private:
  
  
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef gunichar                        value_type;
  typedef int                             difference_type;
  typedef value_type                      reference;
  typedef void                            pointer;

  /** Alias for forward_char(). */
  inline TextIter&      operator++();
  inline const TextIter operator++(int);

  /** Alias for backward_char(). */
  inline TextIter&      operator--();
  inline const TextIter operator--(int);

  /** Alias for get_char(). */
  inline value_type operator*() const;

  /** Alias for !is_end(). */
  inline operator bool() const;

#ifndef DOXYGEN_SHOULD_SKIP_THIS

protected:
  template <class Predicate>
  struct PredicateAdapter
  {
    Predicate predicate_;
    inline PredicateAdapter(const Predicate& predicate);
    static gboolean gtk_callback(gunichar uc, void* user_data);
  };

  
  /** Advances @a iter , calling @a pred  on each character. If
   *  @a pred  returns <tt>true</tt>, returns <tt>true</tt> and stops scanning.
   * If @a pred  never returns <tt>true</tt>, @a iter  is set to @a limit  if
   *  @a limit  is non-<tt>0</tt>, otherwise to the end iterator.
   * @param pred A function to be called on each character.
   * @param user_data User data for @a pred .
   * @param limit Search limit, or <tt>0</tt> for none.
   * @return Whether a match was found.
   */
  bool forward_find_char_impl(GtkTextCharPredicate predicate,
                                           void* user_data,
                                           const GtkTextIter* limit);

  
  /** Same as gtk_text_iter_forward_find_char(), but goes backward from @a iter .
   * @param pred Function to be called on each character.
   * @param user_data User data for @a pred .
   * @param limit Search limit, or <tt>0</tt> for none.
   * @return Whether a match was found.
   */
  bool backward_find_char_impl(GtkTextCharPredicate predicate,
                                            void* user_data,
                                            const GtkTextIter* limit);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:
  
  /** Return value: the buffer
   * @return The buffer.
   */
  Glib::RefPtr<TextBuffer> get_buffer() const;

  
  /** Return value: a character offset
   * @return A character offset.
   */
  int get_offset() const;
  
  /** Return value: a line number
   * @return A line number.
   */
  int get_line() const;
  
  /** Return value: offset from start of line
   * @return Offset from start of line.
   */
  int get_line_offset() const;
  
  /** Return value: distance from start of line, in bytes
   * @return Distance from start of line, in bytes.
   */
  int get_line_index() const;

  
  /** Return value: offset in visible characters from the start of the line
   * @return Offset in visible characters from the start of the line.
   */
  int get_visible_line_offset() const;
  
  /** Return value: byte index of @a iter  with respect to the start of the line
   * @return Byte index of @a iter  with respect to the start of the line.
   */
  int get_visible_line_index() const;

  
  /** returns 0.
   * Return value: a Unicode character, or 0 if @a iter  is not dereferenceable
   * @return A Unicode character, or 0 if @a iter  is not dereferenceable.
   */
  gunichar get_char() const;
  
  /** Return value: slice of text from the buffer
   * @param end Iterator at end of a range.
   * @return Slice of text from the buffer.
   */
  Glib::ustring get_slice(const TextIter& end) const;
  
  /** Return value: array of characters from the buffer
   * @param end Iterator at end of a range.
   * @return Array of characters from the buffer.
   */
  Glib::ustring get_text(const TextIter& end) const;
  
  /** Like gtk_text_iter_get_slice(), but invisible text is not included.
   * Invisible text is usually invisible because a Gtk::TextTag with the
   * "invisible" attribute turned on has been applied to it.
   * @param end Iterator at end of range.
   * @return Slice of text from the buffer.
   */
  Glib::ustring get_visible_slice(const TextIter& end) const;
  
  /** Like gtk_text_iter_get_text(), but invisible text is not included.
   * Invisible text is usually invisible because a Gtk::TextTag with the
   * "invisible" attribute turned on has been applied to it.
   * @param end Iterator at end of range.
   * @return String containing visible text in the range.
   */
  Glib::ustring get_visible_text(const TextIter& end) const;

  
  /** If the element at @a iter  is a pixbuf, the pixbuf is returned
   * (with no new reference count added). Otherwise,
   * <tt>0</tt> is returned.
   * @return The pixbuf at @a iter .
   */
  Glib::RefPtr<Gdk::Pixbuf> get_pixbuf() const;
  
  /** Return value: list of Gtk::TextMark
   * @return List of Gtk::TextMark.
   */
  Glib::SListHandle< Glib::RefPtr<TextMark> > get_marks();
  
  /** Return value: list of Gtk::TextMark
   * @return List of Gtk::TextMark.
   */
  Glib::SListHandle< Glib::RefPtr<const TextMark> > get_marks() const;
  
  
  /** If the location at @a iter  contains a child anchor, the
   * anchor is returned (with no new reference count added). Otherwise,
   * <tt>0</tt> is returned.
   * @return The anchor at @a iter .
   */
  Glib::RefPtr<TextChildAnchor> get_child_anchor();
  
  /** If the location at @a iter  contains a child anchor, the
   * anchor is returned (with no new reference count added). Otherwise,
   * <tt>0</tt> is returned.
   * @return The anchor at @a iter .
   */
  Glib::RefPtr<const TextChildAnchor> get_child_anchor() const;

  
  /** Return value: tags toggled at this point
   * @param toggled_on <tt>true</tt> to get toggled-on tags.
   * @return Tags toggled at this point.
   */
  Glib::SListHandle< Glib::RefPtr<TextTag> > get_toggled_tags(bool toggled_on = true);
  
  /** Return value: tags toggled at this point
   * @param toggled_on <tt>true</tt> to get toggled-on tags.
   * @return Tags toggled at this point.
   */
  Glib::SListHandle< Glib::RefPtr<const TextTag> > get_toggled_tags(bool toggled_on = true) const;

  
  /** Return value: whether @a iter  is the start of a range tagged with @a tag 
   * @param tag A Gtk::TextTag, or <tt>0</tt>.
   * @return Whether @a iter  is the start of a range tagged with @a tag .
   */
  bool begins_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool begins_tag() const;
  
  /** Return value: whether @a iter  is the end of a range tagged with @a tag 
   * @param tag A Gtk::TextTag, or <tt>0</tt>.
   * @return Whether @a iter  is the end of a range tagged with @a tag .
   */
  bool ends_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool ends_tag() const;
  
  /** This is equivalent to (gtk_text_iter_begins_tag() ||
   * gtk_text_iter_ends_tag()), i.e.\ it tells you whether a range with
   *  @a tag  applied to it begins <em>or</em> ends at @a iter .
   * @param tag A Gtk::TextTag, or <tt>0</tt>.
   * @return Whether @a tag  is toggled on or off at @a iter .
   */
  bool toggles_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool toggles_tag() const;

  
  /** Return value: whether @a iter  is tagged with @a tag 
   * @param tag A Gtk::TextTag.
   * @return Whether @a iter  is tagged with @a tag .
   */
  bool has_tag(const Glib::RefPtr<const TextTag>& tag) const;
  bool has_tag() const;
  
  
  /** Returns a list of tags that apply to @a iter , in ascending order of
   * priority (highest-priority tags are last).
   * @return List of Gtk::TextTag.
   */
  Glib::SListHandle< Glib::RefPtr<TextTag> > get_tags();
  
  /** Returns a list of tags that apply to @a iter , in ascending order of
   * priority (highest-priority tags are last).
   * @return List of Gtk::TextTag.
   */
  Glib::SListHandle< Glib::RefPtr<const TextTag> > get_tags() const;

  
  /** Return value: whether @a iter  is inside an editable range
   * @param default_setting <tt>true</tt> if text is editable by default.
   * @return Whether @a iter  is inside an editable range.
   */
  bool editable(bool default_setting = true) const;
  
  /** Considering the default editability of the buffer, and tags that
   * affect editability, determines whether text inserted at @a iter  would
   * be editable. If text inserted at @a iter  would be editable then the
   * user should be allowed to insert text at @a iter .
   * Gtk::TextBuffer::insert_interactive() uses this function to decide
   * whether insertions are allowed at a given position.
   * @param default_editability <tt>true</tt> if text is editable by default.
   * @return Whether text inserted at @a iter  would be editable.
   */
  bool can_insert(bool default_editability = true) const;

  
  /** Determines whether @a iter  begins a natural-language word.  Word
   * breaks are determined by Pango and should be correct for nearly any
   * language (if not, the correct fix would be to the Pango word break
   * algorithms).
   * @return <tt>true</tt> if @a iter  is at the start of a word.
   */
  bool starts_word() const;
  
  /** Determines whether @a iter  ends a natural-language word.  Word breaks
   * are determined by Pango and should be correct for nearly any
   * language (if not, the correct fix would be to the Pango word break
   * algorithms).
   * @return <tt>true</tt> if @a iter  is at the end of a word.
   */
  bool ends_word() const;
  
  /** Determines whether @a iter  is inside a natural-language word (as
   * opposed to say inside some whitespace).  Word breaks are determined
   * by Pango and should be correct for nearly any language (if not, the
   * correct fix would be to the Pango word break algorithms).
   * @return <tt>true</tt> if @a iter  is inside a word.
   */
  bool inside_word() const;
  
  /** Determines whether @a iter  begins a sentence.  Sentence boundaries are
   * determined by Pango and should be correct for nearly any language
   * (if not, the correct fix would be to the Pango text boundary
   * algorithms).
   * @return <tt>true</tt> if @a iter  is at the start of a sentence.
   */
  bool starts_sentence() const;
  
  /** Determines whether @a iter  ends a sentence.  Sentence boundaries are
   * determined by Pango and should be correct for nearly any language
   * (if not, the correct fix would be to the Pango text boundary
   * algorithms).
   * @return <tt>true</tt> if @a iter  is at the end of a sentence.
   */
  bool ends_sentence() const;
  
  /** Determines whether @a iter  is inside a sentence (as opposed to in
   * between two sentences, e.g.\ after a period and before the first
   * letter of the next sentence).  Sentence boundaries are determined
   * by Pango and should be correct for nearly any language (if not, the
   * correct fix would be to the Pango text boundary algorithms).
   * @return <tt>true</tt> if @a iter  is inside a sentence.
   */
  bool inside_sentence() const;
  
  /** Return value: whether @a iter  begins a line
   * @return Whether @a iter  begins a line.
   */
  bool starts_line() const;
  
  /** Return value: whether @a iter  is at the end of a line
   * @return Whether @a iter  is at the end of a line.
   */
  bool ends_line() const;
  
  /** See gtk_text_iter_forward_cursor_position() or Pango::LogAttr or
   * pango_break() for details on what a cursor position is.
   * @return <tt>true</tt> if the cursor can be placed at @a iter .
   */
  bool is_cursor_position() const;

  
  /** Return value: number of characters in the line
   * @return Number of characters in the line.
   */
  int get_chars_in_line() const;
  
  /** Return value: number of bytes in the line
   * @return Number of bytes in the line.
   */
  int get_bytes_in_line() const;

  bool get_attributes(TextAttributes& values) const;
  
  /** A convenience wrapper around gtk_text_iter_get_attributes(),
   * which returns the language in effect at @a iter . If no tags affecting
   * language apply to @a iter , the return value is identical to that of
   * gtk_get_default_language().
   * @return Language in effect at @a iter .
   */
  Pango::Language get_language() const;
  
  /** Return value: whether @a iter  is the end iterator
   * @return Whether @a iter  is the end iterator.
   */
  bool is_end() const;
  
  /** Return value: whether @a iter  is the first in the buffer
   * @return Whether @a iter  is the first in the buffer.
   */
  bool is_start() const;

  
  /** Moves @a iter  forward by one character offset. Note that images
   * embedded in the buffer occupy 1 character slot, so
   * gtk_text_iter_forward_char() may actually move onto an image instead
   * of a character, if you have images in your buffer.  If @a iter  is the
   * end iterator or one character before it, @a iter  will now point at
   * the end iterator, and gtk_text_iter_forward_char() returns <tt>false</tt> for
   * convenience when writing loops.
   * @return Whether @a iter  moved and is dereferenceable.
   */
  bool forward_char();
  
  /** Moves backward by one character offset. Returns <tt>true</tt> if movement
   * was possible; if @a iter  was the first in the buffer (character
   * offset 0), gtk_text_iter_backward_char() returns <tt>false</tt> for convenience when
   * writing loops.
   * @return Whether movement was possible.
   */
  bool backward_char();
  
  /** Moves @a count  characters if possible (if @a count  would move past the
   * start or end of the buffer, moves to the start or end of the
   * buffer). The return value indicates whether the new position of
   *  @a iter  is different from its original position, and dereferenceable
   * (the last iterator in the buffer is not dereferenceable). If @a count 
   * is 0, the function does nothing and returns <tt>false</tt>.
   * @param count Number of characters to move, may be negative.
   * @return Whether @a iter  moved and is dereferenceable.
   */
  bool forward_chars(int count);
  
  /** Moves @a count  characters backward, if possible (if @a count  would move
   * past the start or end of the buffer, moves to the start or end of
   * the buffer).  The return value indicates whether the iterator moved
   * onto a dereferenceable position; if the iterator didn't move, or
   * moved onto the end iterator, then <tt>false</tt> is returned. If @a count  is 0,
   * the function does nothing and returns <tt>false</tt>.
   * @param count Number of characters to move.
   * @return Whether @a iter  moved and is dereferenceable.
   */
  bool backward_chars(int count);
  
  /** Moves @a iter  to the start of the next line. Returns <tt>true</tt> if there
   * was a next line to move to, and <tt>false</tt> if @a iter  was simply moved to
   * the end of the buffer and is now not dereferenceable, or if @a iter  was
   * already at the end of the buffer.
   * @return Whether @a iter  can be dereferenced.
   */
  bool forward_line();
  
  /** Moves @a iter  to the start of the previous line. Returns <tt>true</tt> if
   *  @a iter  could be moved; i.e. if @a iter  was at character offset 0, this
   * function returns <tt>false</tt>. Therefore if @a iter  was already on line 0,
   * but not at the start of the line, @a iter  is snapped to the start of
   * the line and the function returns <tt>true</tt>. (Note that this implies that
   * in a loop calling this function, the line number may not change on
   * every iteration, if your first iteration is on line 0.)
   * @return Whether @a iter  moved.
   */
  bool backward_line();
  
  /** Moves @a count  lines forward, if possible (if @a count  would move
   * past the start or end of the buffer, moves to the start or end of
   * the buffer).  The return value indicates whether the iterator moved
   * onto a dereferenceable position; if the iterator didn't move, or
   * moved onto the end iterator, then <tt>false</tt> is returned. If @a count  is 0,
   * the function does nothing and returns <tt>false</tt>. If @a count  is negative,
   * moves backward by 0 - @a count  lines.
   * @param count Number of lines to move forward.
   * @return Whether @a iter  moved and is dereferenceable.
   */
  bool forward_lines(int count);
  
  /** Moves @a count  lines backward, if possible (if @a count  would move
   * past the start or end of the buffer, moves to the start or end of
   * the buffer).  The return value indicates whether the iterator moved
   * onto a dereferenceable position; if the iterator didn't move, or
   * moved onto the end iterator, then <tt>false</tt> is returned. If @a count  is 0,
   * the function does nothing and returns <tt>false</tt>. If @a count  is negative,
   * moves forward by 0 - @a count  lines.
   * @param count Number of lines to move backward.
   * @return Whether @a iter  moved and is dereferenceable.
   */
  bool backward_lines(int count);
  
  /** Moves forward to the next word end. (If @a iter  is currently on a
   * word end, moves forward to the next one after that.) Word breaks
   * are determined by Pango and should be correct for nearly any
   * language (if not, the correct fix would be to the Pango word break
   * algorithms).
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool forward_word_end();
  
  /** Moves backward to the previous word start. (If @a iter  is currently on a
   * word start, moves backward to the next one after that.) Word breaks
   * are determined by Pango and should be correct for nearly any
   * language (if not, the correct fix would be to the Pango word break
   * algorithms).
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool backward_word_start();
  
  /** Calls gtk_text_iter_forward_word_end() up to @a count  times.
   * @param count Number of times to move.
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool forward_word_ends(int count);
  
  /** Calls gtk_text_iter_backward_word_start() up to @a count  times.
   * @param count Number of times to move.
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool backward_word_starts(int count);

  
  /** Moves @a iter  to the start of the next visible line. Returns <tt>true</tt> if there
   * was a next line to move to, and <tt>false</tt> if @a iter  was simply moved to
   * the end of the buffer and is now not dereferenceable, or if @a iter  was
   * already at the end of the buffer.
   * @return Whether @a iter  can be dereferenced
   * 
   * @newin2p8.
   */
  bool forward_visible_line();
  
  /** Moves @a iter  to the start of the previous visible line. Returns <tt>true</tt> if
   *  @a iter  could be moved; i.e. if @a iter  was at character offset 0, this
   * function returns <tt>false</tt>. Therefore if @a iter  was already on line 0,
   * but not at the start of the line, @a iter  is snapped to the start of
   * the line and the function returns <tt>true</tt>. (Note that this implies that
   * in a loop calling this function, the line number may not change on
   * every iteration, if your first iteration is on line 0.)
   * @return Whether @a iter  moved
   * 
   * @newin2p8.
   */
  bool backward_visible_line();
  
  /** Moves @a count  visible lines forward, if possible (if @a count  would move
   * past the start or end of the buffer, moves to the start or end of
   * the buffer).  The return value indicates whether the iterator moved
   * onto a dereferenceable position; if the iterator didn't move, or
   * moved onto the end iterator, then <tt>false</tt> is returned. If @a count  is 0,
   * the function does nothing and returns <tt>false</tt>. If @a count  is negative,
   * moves backward by 0 - @a count  lines.
   * @param count Number of lines to move forward.
   * @return Whether @a iter  moved and is dereferenceable
   * 
   * @newin2p8.
   */
  bool forward_visible_line(int count);
  
  /** Moves @a count  visible lines backward, if possible (if @a count  would move
   * past the start or end of the buffer, moves to the start or end of
   * the buffer).  The return value indicates whether the iterator moved
   * onto a dereferenceable position; if the iterator didn't move, or
   * moved onto the end iterator, then <tt>false</tt> is returned. If @a count  is 0,
   * the function does nothing and returns <tt>false</tt>. If @a count  is negative,
   * moves forward by 0 - @a count  lines.
   * @param count Number of lines to move backward.
   * @return Whether @a iter  moved and is dereferenceable
   * 
   * @newin2p8.
   */
  bool backward_visible_lines(int count);

  //TODO: Now that there are so many *_visible_ versions of the methods, maybe we should
  //just add a visible=false parameter and therefore halve the number of methods. murrayc
 
  
  /** Moves forward to the next visible word end. (If @a iter  is currently on a
   * word end, moves forward to the next one after that.) Word breaks
   * are determined by Pango and should be correct for nearly any
   * language (if not, the correct fix would be to the Pango word break
   * algorithms).
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator 
   * 
   * @newin2p4.
   */
  bool forward_visible_word_end();
  
  /** Moves backward to the previous visible word start. (If @a iter  is currently 
   * on a word start, moves backward to the next one after that.) Word breaks
   * are determined by Pango and should be correct for nearly any
   * language (if not, the correct fix would be to the Pango word break
   * algorithms).
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator 
   * 
   * @newin2p4.
   */
  bool backward_visible_word_start();
  
  /** Calls gtk_text_iter_forward_visible_word_end() up to @a count  times.
   * @param count Number of times to move.
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator 
   * 
   * @newin2p4.
   */
  bool forward_visible_word_ends(int count);
  
  /** Calls gtk_text_iter_backward_visible_word_start() up to @a count  times.
   * @param count Number of times to move.
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator 
   * 
   * @newin2p4.
   */
  bool backward_visible_word_starts(int count);

  
  /** Moves forward to the next sentence end. (If @a iter  is at the end of
   * a sentence, moves to the next end of sentence.)  Sentence
   * boundaries are determined by Pango and should be correct for nearly
   * any language (if not, the correct fix would be to the Pango text
   * boundary algorithms).
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool forward_sentence_end();
  
  /** Moves backward to the previous sentence start; if @a iter  is already at
   * the start of a sentence, moves backward to the next one.  Sentence
   * boundaries are determined by Pango and should be correct for nearly
   * any language (if not, the correct fix would be to the Pango text
   * boundary algorithms).
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool backward_sentence_start();
  
  /** Calls gtk_text_iter_forward_sentence_end() @a count  times (or until
   * gtk_text_iter_forward_sentence_end() returns <tt>false</tt>). If @a count  is
   * negative, moves backward instead of forward.
   * @param count Number of sentences to move.
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool forward_sentence_ends(int count);
  
  /** Calls gtk_text_iter_backward_sentence_start() up to @a count  times,
   * or until it returns <tt>false</tt>. If @a count  is negative, moves forward
   * instead of backward.
   * @param count Number of sentences to move.
   * @return <tt>true</tt> if @a iter  moved and is not the end iterator.
   */
  bool backward_sentence_starts(int count);

  
  /** Moves @a iter  forward by a single cursor position. Cursor positions
   * are (unsurprisingly) positions where the cursor can appear. Perhaps
   * surprisingly, there may not be a cursor position between all
   * characters. The most common example for European languages would be
   * a carriage return/newline sequence. For some Unicode characters,
   * the equivalent of say the letter "a" with an accent mark will be
   * represented as two characters, first the letter then a "combining
   * mark" that causes the accent to be rendered; so the cursor can't go
   * between those two characters. See also the Pango::LogAttr structure and
   * pango_break() function.
   * @return <tt>true</tt> if we moved and the new position is dereferenceable.
   */
  bool forward_cursor_position();
  
  /** Like gtk_text_iter_forward_cursor_position(), but moves backward.
   * @return <tt>true</tt> if we moved.
   */
  bool backward_cursor_position();
  
  /** Moves up to @a count  cursor positions. See
   * gtk_text_iter_forward_cursor_position() for details.
   * @param count Number of positions to move.
   * @return <tt>true</tt> if we moved and the new position is dereferenceable.
   */
  bool forward_cursor_positions(int count);
  
  /** Moves up to @a count  cursor positions. See
   * gtk_text_iter_forward_cursor_position() for details.
   * @param count Number of positions to move.
   * @return <tt>true</tt> if we moved and the new position is dereferenceable.
   */
  bool backward_cursor_positions(int count);

  
  /** Moves @a iter  forward to the next visible cursor position. See 
   * gtk_text_iter_forward_cursor_position() for details.
   * @return <tt>true</tt> if we moved and the new position is dereferenceable
   * 
   * @newin2p4.
   */
  bool forward_visible_cursor_position();
  
  /** Moves @a iter  forward to the previous visible cursor position. See 
   * gtk_text_iter_backward_cursor_position() for details.
   * @return <tt>true</tt> if we moved and the new position is dereferenceable
   * 
   * @newin2p4.
   */
  bool backward_visible_cursor_position();
  
  /** Moves up to @a count  visible cursor positions. See
   * gtk_text_iter_forward_cursor_position() for details.
   * @param count Number of positions to move.
   * @return <tt>true</tt> if we moved and the new position is dereferenceable
   * 
   * @newin2p4.
   */
  bool forward_visible_cursor_positions(int count);
  
  /** Moves up to @a count  visible cursor positions. See
   * gtk_text_iter_backward_cursor_position() for details.
   * @param count Number of positions to move.
   * @return <tt>true</tt> if we moved and the new position is dereferenceable
   * 
   * @newin2p4.
   */
  bool backward_visible_cursor_positions(int count);

  
  /** Sets @a iter  to point to @a char_offset . @a char_offset  counts from the start
   * of the entire text buffer, starting with 0.
   * @param char_offset A character number.
   */
  void set_offset(int char_offset);
  
  /** Moves iterator @a iter  to the start of the line @a line_number .  If
   *  @a line_number  is negative or larger than the number of lines in the
   * buffer, moves @a iter  to the start of the last line in the buffer.
   * @param line_number Line number (counted from 0).
   */
  void set_line(int line_number);
  
  /** Moves @a iter  within a line, to a new <em>character</em>
   * (not byte) offset. The given character offset must be less than or
   * equal to the number of characters in the line; if equal, @a iter 
   * moves to the start of the next line. See
   * gtk_text_iter_set_line_index() if you have a byte index rather than
   * a character offset.
   * @param char_on_line A character offset relative to the start of @a iter 's current line.
   */
  void set_line_offset(int char_on_line);
  
  /** Same as gtk_text_iter_set_line_offset(), but works with a
   * <em>byte</em> index. The given byte index must be at
   * the start of a character, it can't be in the middle of a UTF-8
   * encoded character.
   * @param byte_on_line A byte index relative to the start of @a iter 's current line.
   */
  void set_line_index(int byte_on_line);
  
  /** Moves @a iter  forward to the "end iterator," which points one past the last
   * valid character in the buffer. gtk_text_iter_get_char() called on the
   * end iterator returns 0, which is convenient for writing loops.
   */
  void forward_to_end();
  
  /** Moves the iterator to point to the paragraph delimiter characters,
   * which will be either a newline, a carriage return, a carriage
   * return/newline in sequence, or the Unicode paragraph separator
   * character. If the iterator is already at the paragraph delimiter
   * characters, moves to the paragraph delimiter characters for the
   * next line. If @a iter  is on the last line in the buffer, which does
   * not end in paragraph delimiters, moves to the end iterator (end of
   * the last line), and returns <tt>false</tt>.
   * @return <tt>true</tt> if we moved and the new location is not the end iterator.
   */
  bool forward_to_line_end();

  
  /** Like gtk_text_iter_set_line_offset(), but the offset is in visible
   * characters, i.e.\ text with a tag making it invisible is not
   * counted in the offset.
   * @param char_on_line A character offset.
   */
  void set_visible_line_offset(int char_on_line);
  
  /** Like gtk_text_iter_set_line_index(), but the index is in visible
   * bytes, i.e.\ text with a tag making it invisible is not counted
   * in the index.
   * @param byte_on_line A byte index.
   */
  void set_visible_line_index(int byte_on_line);

  
  /** Moves forward to the next toggle (on or off) of the
   * Gtk::TextTag @a tag , or to the next toggle of any tag if
   *  @a tag  is <tt>0</tt>. If no matching tag toggles are found,
   * Return value: whether we found a tag toggle after @a iter 
   * @param tag A Gtk::TextTag, or <tt>0</tt>.
   * @return Whether we found a tag toggle after @a iter .
   */
  bool forward_to_tag_toggle(const Glib::RefPtr<TextTag>& tag);
  
  /** Moves backward to the next toggle (on or off) of the
   * Gtk::TextTag @a tag , or to the next toggle of any tag if
   *  @a tag  is <tt>0</tt>. If no matching tag toggles are found,
   * Return value: whether we found a tag toggle before @a iter 
   * @param tag A Gtk::TextTag, or <tt>0</tt>.
   * @return Whether we found a tag toggle before @a iter .
   */
  bool backward_to_tag_toggle(const Glib::RefPtr<TextTag>& tag);

  template <class Predicate> bool forward_find_char(const Predicate& predicate, const TextIter& limit);
  template <class Predicate> bool forward_find_char(const Predicate& predicate);
  template <class Predicate> bool backward_find_char(const Predicate& predicate, const TextIter& limit);
  template <class Predicate> bool backward_find_char(const Predicate& predicate);

  
  /** Searches forward for @a str . Any match is returned by setting 
   *  @a match_start  to the first character of the match and @a match_end  to the 
   * first character after the match. The search will not continue past
   *  @a limit . Note that a search is a linear or O(n) operation, so you
   * may wish to use @a limit  to avoid locking up your UI on large
   * buffers.
   * 
   * If the Gtk::TEXT_SEARCH_VISIBLE_ONLY flag is present, the match may
   * have invisible text interspersed in @a str . i.e. @a str  will be a
   * possibly-noncontiguous subsequence of the matched range. similarly,
   * if you specify Gtk::TEXT_SEARCH_TEXT_ONLY, the match may have
   * pixbufs or child widgets mixed inside the matched range. If these
   * flags are not given, the match must be exact; the special 0xFFFC
   * character in @a str  will match embedded pixbufs or child widgets.
   * @param str A search string.
   * @param flags Flags affecting how the search is done.
   * @param match_start Return location for start of match.
   * @param match_end Return location for end of match.
   * @param limit Bound for the search.
   * @return Whether a match was found.
   */
  bool forward_search(const Glib::ustring& str,
                                   TextSearchFlags flags,
                                   TextIter& match_start,
                                   TextIter& match_end,
                                   const TextIter& limit) const;
         
  /** Same as forward_search(), but searchs to the end.
   *
   * @param str A search string.
   * @param flags Flags affecting how the search is done.
   * @param match_start Return location for start of match, or <tt>0</tt>.
   * @param match_end Return location for end of match, or <tt>0</tt>.
   * @return Whether a match was found.
   */                          
   bool forward_search(const Glib::ustring& str, TextSearchFlags flags, TextIter& match_start, TextIter& match_end) const;

  
  /** Same as gtk_text_iter_forward_search(), but moves backward.
   * @param str Search string.
   * @param flags Bitmask of flags affecting the search.
   * @param match_start Return location for start of match.
   * @param match_end Return location for end of match.
   * @param limit Location of last possible @a match_start .
   * @return Whether a match was found.
   */
  bool backward_search(const Glib::ustring& str,
                                    TextSearchFlags flags,
                                    TextIter& match_start,
                                    TextIter& match_end,
                                    const TextIter& limit) const;

  /** Same as backward_search(), but searches to the start.
   * @param str Search string.
   * @param flags Bitmask of flags affecting the search.
   * @param match_start Return location for start of match, or <tt>0</tt>.
   * @param match_end Return location for end of match, or <tt>0</tt>.
   * @return Whether a match was found.
   */                                    
  bool backward_search(const Glib::ustring& str, TextSearchFlags flags, TextIter& match_start, TextIter& match_end) const;

  
  /** A qsort()-style function that returns negative if @a lhs  is less than
   *  @a rhs , positive if @a lhs  is greater than @a rhs , and 0 if they're equal.
   * Ordering is in character offset order, i.e. the first character in the buffer
   * is less than the second character in the buffer.
   * @param rhs Another Gtk::TextIter.
   * @return -1 if @a lhs  is less than @a rhs , 1 if @a lhs  is greater, 0 if they are equal.
   */
  int compare(const TextIter& rhs) const;
  
  /** Checks whether @a iter  falls in the range [ @a start , @a end ).
   *  @a start  and @a end  must be in ascending order.
   * @param start Start of range.
   * @param end End of range.
   * @return <tt>true</tt> if @a iter  is in the range.
   */
  bool in_range(const TextIter& start, const TextIter& end) const;
  
  /** Swaps the value of @a first  and @a second  if @a second  comes before
   *  @a first  in the buffer. That is, ensures that @a first  and @a second  are
   * in sequence. Most text buffer functions that take a range call this
   * automatically on your behalf, so there's no real reason to call it yourself
   * in those cases. There are some exceptions, such as gtk_text_iter_in_range(),
   * that expect a pre-sorted range.
   * @param second Another Gtk::TextIter.
   */
  void order(TextIter& second);

  
};


#ifndef DOXYGEN_SHOULD_SKIP_THIS

template <class Predicate> inline
TextIter::PredicateAdapter<Predicate>::PredicateAdapter(const Predicate& predicate)
:
  predicate_ (predicate)
{}

// static
template <class Predicate>
gboolean TextIter::PredicateAdapter<Predicate>::gtk_callback(gunichar uc, void* user_data)
{
  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  try
  {
  #endif //GLIBMM_EXCEPTIONS_ENABLED
    // This will either use Predicate::operator(), or call a function pointer.
    // The explicit conditional expression avoids relying on an implicit
    // conversion of the return type to int, which might be not available.
    return (static_cast<TextIter::PredicateAdapter<Predicate>*>(user_data)->predicate_(uc)) ? 1 : 0;
  #ifdef GLIBMM_EXCEPTIONS_ENABLED
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
    return 0;
  }
  #endif //GLIBMM_EXCEPTIONS_ENABLED
}

inline
TextIter& TextIter::operator++()
{
  forward_char();
  return *this;
}

inline
const TextIter TextIter::operator++(int)
{
  const TextIter temp (*this);
  forward_char();
  return temp;
}

inline
TextIter& TextIter::operator--()
{
  backward_char();
  return *this;
}

inline
const TextIter TextIter::operator--(int)
{
  const TextIter temp (*this);
  backward_char();
  return temp;
}

inline
TextIter::value_type TextIter::operator*() const
{
  return get_char();
}

inline
TextIter::operator bool() const
{
  return !is_end();
}

template <class Predicate>
bool TextIter::forward_find_char(const Predicate& predicate, const TextIter& limit)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->forward_find_char_impl(&PredAdapter::gtk_callback, &adapter, limit.gobj());
}

template <class Predicate>
bool TextIter::forward_find_char(const Predicate& predicate)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->forward_find_char_impl(&PredAdapter::gtk_callback, &adapter, 0);
}

template <class Predicate>
bool TextIter::backward_find_char(const Predicate& predicate, const TextIter& limit)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->backward_find_char_impl(&PredAdapter::gtk_callback, &adapter, limit.gobj());
}

template <class Predicate>
bool TextIter::backward_find_char(const Predicate& predicate)
{
  typedef TextIter::PredicateAdapter<Predicate> PredAdapter;
  PredAdapter adapter (predicate);
  return this->backward_find_char_impl(&PredAdapter::gtk_callback, &adapter, 0);
}

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} // namespace Gtk


namespace Gtk
{

/** @relates Gtk::TextIter
 * @param lhs The left-hand side
 * @param rhs The right-hand side
 * @result The result
 */
bool operator==(const TextIter& lhs, const TextIter& rhs);

/** @relates Gtk::TextIter
 * @param lhs The left-hand side
 * @param rhs The right-hand side
 * @result The result
 */
bool operator!=(const TextIter& lhs, const TextIter& rhs);

/** @relates Gtk::TextIter
 * @param lhs The left-hand side
 * @param rhs The right-hand side
 * @result The result
 */
bool operator<(const TextIter& lhs, const TextIter& rhs);

/** @relates Gtk::TextIter
 * @param lhs The left-hand side
 * @param rhs The right-hand side
 * @result The result
 */
bool operator>(const TextIter& lhs, const TextIter& rhs);

/** @relates Gtk::TextIter
 * @param lhs The left-hand side
 * @param rhs The right-hand side
 * @result The result
 */
bool operator<=(const TextIter& lhs, const TextIter& rhs);

/** @relates Gtk::TextIter
 * @param lhs The left-hand side
 * @param rhs The right-hand side
 * @result The result
 */
bool operator>=(const TextIter& lhs, const TextIter& rhs);


} // namespace Gtk


namespace Glib
{

/** @relates Gtk::TextIter
 * @param object The C instance
 * @result A C++ instance that wraps this C instance.
 */
Gtk::TextIter& wrap(GtkTextIter* object);

/** @relates Gtk::TextIter
 * @param object The C instance
 * @result A C++ instance that wraps this C instance.
 */
const Gtk::TextIter& wrap(const GtkTextIter* object);

#ifndef DOXYGEN_SHOULD_SKIP_THIS
template <>
class Value<Gtk::TextIter> : public Glib::Value_Boxed<Gtk::TextIter>
{};
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} // namespace Glib


#endif /* _GTKMM_TEXTITER_H */

