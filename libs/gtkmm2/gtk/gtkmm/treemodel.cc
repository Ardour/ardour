// Generated by gtkmmproc -- DO NOT MODIFY!

#include <gtkmm/treemodel.h>
#include <gtkmm/private/treemodel_p.h>

#include <gtk/gtktypebuiltins.h>
// -*- c++ -*-
/* $Id$ */

/* Copyright 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/treeiter.h>
#include <gtkmm/treepath.h>
#include <gtk/gtktreestore.h>
#include <gtk/gtktreemodel.h>

namespace
{

gboolean proxy_foreach_iter_callback(GtkTreeModel* model, GtkTreePath*, GtkTreeIter* iter, void* data)
{
  typedef Gtk::TreeModel::SlotForeachIter SlotType;
  SlotType& slot = *static_cast<SlotType*>(data);

  try
  {
    return slot(Gtk::TreeModel::iterator(model, iter));
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }

  return 1;
}

gboolean proxy_foreach_path_callback(GtkTreeModel*, GtkTreePath* path, GtkTreeIter*, void* data)
{
  typedef Gtk::TreeModel::SlotForeachPath SlotType;
  SlotType& slot = *static_cast<SlotType*>(data);

  try
  {
    return slot(Gtk::TreeModel::Path(path, true));
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }

  return 1;
}

gboolean proxy_foreach_path_and_iter_callback(GtkTreeModel* model, GtkTreePath* path,
                                              GtkTreeIter* iter, void* data)
{
  typedef Gtk::TreeModel::SlotForeachPathAndIter SlotType;
  SlotType& slot = *static_cast<SlotType*>(data);

  try
  {
    return slot(Gtk::TreeModel::Path(path, true), Gtk::TreeModel::iterator(model, iter));
  }
  catch(...)
  {
    Glib::exception_handlers_invoke();
  }

  return 1;
}

} //anonymous namespace


//Help the code generator, so that it doesn't have to fully qualify this type:
typedef Gtk::TreeModel::iterator iterator;

namespace Gtk
{

TreeModel::iterator TreeModel::get_iter(const Path& path)
{
  Gtk::TreeModel::iterator iter(this);
  gtk_tree_model_get_iter(gobj(), iter.gobj(), const_cast<GtkTreePath*>(path.gobj()));
  return iter;
}

TreeModel::iterator TreeModel::get_iter(const Glib::ustring& path_string)
{
  Gtk::TreeModel::iterator iter (this);
  gtk_tree_model_get_iter_from_string(gobj(), iter.gobj(), path_string.c_str());
  return iter;
}

TreeModel::Children TreeModel::children()
{
  return TreeNodeChildren(this);
}

TreeModel::Children TreeModel::children() const
{              
  //TODO: Remove the const when we have a real const TreeNodeChildren, when we have a real const_iterator.
  return TreeNodeChildren(const_cast<TreeModel*>(this));
}

void TreeModel::set_value_impl(const iterator&, int, const Glib::ValueBase&)
{
  g_assert_not_reached();
}

void TreeModel::get_value_impl(const iterator& row, int column, Glib::ValueBase& value) const
{
  gtk_tree_model_get_value(
      const_cast<GtkTreeModel*>(gobj()),
      const_cast<GtkTreeIter*>(row.gobj()),
      column, value.gobj());
}

void TreeModel::foreach_iter(const SlotForeachIter& slot)
{
  SlotForeachIter slot_copy (slot);
  gtk_tree_model_foreach(gobj(), &proxy_foreach_iter_callback, &slot_copy);
}

void TreeModel::foreach_path(const SlotForeachPath& slot)
{
  SlotForeachPath slot_copy (slot);
  gtk_tree_model_foreach(gobj(), &proxy_foreach_path_callback, &slot_copy);
}

void TreeModel::foreach(const SlotForeachPathAndIter& slot)
{
  SlotForeachPathAndIter slot_copy (slot);
  gtk_tree_model_foreach(gobj(), &proxy_foreach_path_and_iter_callback, &slot_copy);
}

bool TreeModel::iter_is_valid(const iterator& iter) const
{
  //This method is overriden in TreeStore and ListStore.
  //This implementation will only be used as a default for custom derived TreeModels,
  //and when we wrap a C GtkTreeModel with a Gtk::TreeModel instance, without knowing what derived C type it is.
  
  // This check is almost the same as the private VALID_ITER() macro in gtkliststore.c and
  // gtktreestore.c.
  return (!iter.is_end_ && iter.gobj()->stamp != 0);
}

// Custom vfunc callbacks, because the C++ vfuncs have different parameters and return types
// that can not be generated automatically:
gboolean TreeModel_Class::iter_next_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      TreeModel::iterator iter_input = TreeModel::iterator(self, iter);
      TreeModel::iterator iter_next( self, iter ); //Copies iter by value.
      gboolean test = obj->iter_next_vfunc(iter_input, iter_next);

      //Copy the new iter value to the C output parameter:
      if(test)
        *iter = *(iter_next.gobj());

      return test;
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
        g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
      )
    );

    // Call the original underlying C function:
    if(base && base->iter_next)
      return (*base->iter_next)(self, iter);
  }

  typedef gboolean RType;
  return RType();
}


bool TreeModel::iter_next_vfunc(const iterator& iter, iterator& iter_next) const
{
  //Call the default C implementation:
  
  BaseClassType *const base = static_cast<BaseClassType*>(
    g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
      g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
    )
  );

  if(base && base->iter_next)
  {
    TreeModel::iterator iter_copy = iter;
    gboolean test = (*base->iter_next)(const_cast<GtkTreeModel*>(gobj()), iter_copy.gobj());
    if(test)
      iter_next = iter_copy;

    return test;
  }

  return bool();
}

gboolean TreeModel_Class::get_iter_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter, GtkTreePath* path)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      Gtk::TreeModel::iterator iter_out(self, iter); //copies the iter by value.
      gboolean test = obj->get_iter_vfunc(Gtk::TreePath(path, true), iter_out);

      //Copy the new iter value to the C output parameter:
      if(test)
        *iter = *(iter_out.gobj());

      return test;
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->get_iter)
      return (*base->get_iter)(self, iter, const_cast<GtkTreePath*>(path));
  }

  typedef gboolean RType;
  return RType();
}

bool TreeModel::get_iter_vfunc(const Path& path, iterator& iter) const
{
  //Call the default C implementation:

  BaseClassType *const base = static_cast<BaseClassType*>(
    g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
      g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
    )
  );

  if(base && base->get_iter)
  {
    return (*base->get_iter)( const_cast<GtkTreeModel*>(gobj()), iter.gobj(), const_cast<GtkTreePath*>(path.gobj()) );
  }

  return bool();
}

gboolean TreeModel_Class::iter_children_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter, GtkTreeIter* parent)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      Gtk::TreeModel::iterator iter_out(self, iter); //copies the iter by value.

      gboolean test = false;
      if(!parent)
      {
        //Deal with this case, which is documented in the C docs as:
        //" If @parent is %NULL returns the first node, equivalent to
        //  <literal>gtk_tree_model_get_iter_first (tree_model, iter);</literal> "
        test = obj->iter_nth_root_child_vfunc(0, iter_out);
      }
      else
      {
        //Normal case: 
         Gtk::TreeModel::iterator parent_cpp(self, parent);
         test = obj->iter_children_vfunc(parent_cpp, iter_out);
      }

      //Copy the new iter value to the C output parameter:
      if(test)
        *iter = *(iter_out.gobj());
        
      return test;
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->iter_children)
      return (*base->iter_children)(self, iter, parent);
  }

  typedef gboolean RType;
  return RType();
}

bool TreeModel::iter_children_vfunc(const iterator& parent, iterator& iter) const
{
  //Call the default C implementation:

  BaseClassType *const base = static_cast<BaseClassType*>(
    g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
      g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
    )
  );

  if(base && base->iter_children)
  {
    return (*base->iter_children)( const_cast<GtkTreeModel*>(gobj()), iter.gobj(), const_cast<GtkTreeIter*>(parent.gobj()) );
  }

  return bool();
}

gboolean TreeModel_Class::iter_parent_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter, GtkTreeIter* child)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      Gtk::TreeModel::iterator iter_out(self, iter);
      Gtk::TreeModel::iterator child_cpp(self, child);
      gboolean test = obj->iter_parent_vfunc(child_cpp, iter_out);

      //Copy the new iter value to the C output parameter:
      if(test)
        *iter = *(iter_out.gobj());

      return test;
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->iter_parent)
      return (*base->iter_parent)(self, iter, child);
  }

  typedef gboolean RType;
  return RType();
}

bool TreeModel::iter_parent_vfunc(const iterator& child, iterator& iter) const
{
  //Call the default C implementation:

  BaseClassType *const base = static_cast<BaseClassType*>(
    g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
      g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
    )
  );

  if(base && base->iter_parent)
  {
    return (*base->iter_parent)( const_cast<GtkTreeModel*>(gobj()), iter.gobj(), const_cast<GtkTreeIter*>(child.gobj()) );
  }

  return bool();
}

gboolean TreeModel_Class::iter_nth_child_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter, GtkTreeIter* parent, int n)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      Gtk::TreeModel::iterator iter_out(self, iter);

      gboolean test = false;
      if(!parent)
      {
        // Deal with this special case, docuemnted in the C docs as:
        // "As a special case, if @parent is %NULL, then the nth root node is set.":
        test = obj->iter_nth_root_child_vfunc(n, iter_out);
      }
      else
      {
        //The normal case:
        Gtk::TreeModel::iterator parent_cpp(self, parent);
        test = obj->iter_nth_child_vfunc(parent_cpp, n, iter_out);
      }

      //Copy the new iter value to the C output parameter:
      if(test)
        *iter = *(iter_out.gobj());

      return test;
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->iter_nth_child)
      return (*base->iter_nth_child)(self, iter, parent, n);
  }

  typedef gboolean RType;
  return RType();
}

bool TreeModel::iter_nth_child_vfunc(const iterator& parent, int n, iterator& iter) const
{
  //Call the default C implementation:

  BaseClassType *const base = static_cast<BaseClassType*>(
    g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
      g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
    )
  );

  if(base && base->iter_nth_child)
  {
    return (*base->iter_nth_child)( const_cast<GtkTreeModel*>(gobj()), iter.gobj(), const_cast<GtkTreeIter*>(parent.gobj()), n );
  }

  return bool();
}

//See the implementation of iter_children_vfunc_callback() and iter_nth_child_vfunc_callback()
//to find out why this virtual function exists:
bool TreeModel::iter_nth_root_child_vfunc(int n, iterator& iter) const
{
  //Call the default C implementation:

  BaseClassType *const base = static_cast<BaseClassType*>(
    g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
      g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
    )
  );

  if(base && base->iter_nth_child)
  {
    //This means that iter_nth_child(0) might be called by iter_children_vfunc_callback(),
    //but hopefully that's exactly the same thing. TODO: Ask why both vfuncs exist. murrayc. 
    return (*base->iter_nth_child)( const_cast<GtkTreeModel*>(gobj()), iter.gobj(), 0 /* the null parent */, n );
  }

  return bool();
}

gboolean TreeModel_Class::iter_n_children_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.

      //Deal with the case that iter is null, as described in the C docs:
      if(iter)
        return obj->iter_n_children_vfunc( Gtk::TreeModel::iterator(self, iter) );
      else
        return obj->iter_n_root_children_vfunc();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->iter_n_children)
      return (*base->iter_n_children)(self, iter);
  }

  typedef gboolean RType;
  return RType();
}

int TreeModel::iter_n_children_vfunc(const iterator& iter) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->iter_n_children)
    return (*base->iter_n_children)(const_cast<GtkTreeModel*>(gobj()), const_cast<GtkTreeIter*>((iter).gobj()));

  typedef int RType;
  return RType();
}

int TreeModel::iter_n_root_children_vfunc() const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->iter_n_children)
    return (*base->iter_n_children)(const_cast<GtkTreeModel*>(gobj()), 0 /* null iter to mean root node, as described in C docs */);

  typedef int RType;
  return RType();
}


void TreeModel::rows_reordered(const Path& path, const iterator& iter, const Glib::ArrayHandle<int>& new_order)
{
  //The size of the array seems to be based on the known number of children. murrayc.
  gtk_tree_model_rows_reordered(gobj(), const_cast<GtkTreePath*>((path).gobj()), const_cast<GtkTreeIter*>((iter).gobj()), const_cast<int*>(new_order.data()));
}
 

} // namespace Gtk


namespace
{

void TreeModel_signal_row_changed_callback(GtkTreeModel* self, GtkTreePath* path,GtkTreeIter* iter,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const TreeModel::Path&,const TreeModel::iterator& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo TreeModel_signal_row_changed_info =
{
  "row_changed",
  (GCallback) &TreeModel_signal_row_changed_callback,
  (GCallback) &TreeModel_signal_row_changed_callback
};


void TreeModel_signal_row_inserted_callback(GtkTreeModel* self, GtkTreePath* path,GtkTreeIter* iter,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const TreeModel::Path&,const TreeModel::iterator& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo TreeModel_signal_row_inserted_info =
{
  "row_inserted",
  (GCallback) &TreeModel_signal_row_inserted_callback,
  (GCallback) &TreeModel_signal_row_inserted_callback
};


void TreeModel_signal_row_has_child_toggled_callback(GtkTreeModel* self, GtkTreePath* path,GtkTreeIter* iter,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const TreeModel::Path&,const TreeModel::iterator& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo TreeModel_signal_row_has_child_toggled_info =
{
  "row_has_child_toggled",
  (GCallback) &TreeModel_signal_row_has_child_toggled_callback,
  (GCallback) &TreeModel_signal_row_has_child_toggled_callback
};


void TreeModel_signal_row_deleted_callback(GtkTreeModel* self, GtkTreePath* path,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const TreeModel::Path& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Gtk::TreePath(path, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo TreeModel_signal_row_deleted_info =
{
  "row_deleted",
  (GCallback) &TreeModel_signal_row_deleted_callback,
  (GCallback) &TreeModel_signal_row_deleted_callback
};


void TreeModel_signal_rows_reordered_callback(GtkTreeModel* self, GtkTreePath* path,GtkTreeIter* iter,gint* new_order,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const TreeModel::Path&,const TreeModel::iterator&,int* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
, new_order
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo TreeModel_signal_rows_reordered_info =
{
  "rows_reordered",
  (GCallback) &TreeModel_signal_rows_reordered_callback,
  (GCallback) &TreeModel_signal_rows_reordered_callback
};

} // anonymous namespace

// static
GType Glib::Value<Gtk::TreeModelFlags>::value_type()
{
  return gtk_tree_model_flags_get_type();
}


namespace Glib
{

Glib::RefPtr<Gtk::TreeModel> wrap(GtkTreeModel* object, bool take_copy)
{
  return Glib::RefPtr<Gtk::TreeModel>( dynamic_cast<Gtk::TreeModel*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} // namespace Glib


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Interface_Class& TreeModel_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Interface_Class has to know the interface init function
    // in order to add interfaces to implementing types.
    class_init_func_ = &TreeModel_Class::iface_init_function;

    // We can not derive from another interface, and it is not necessary anyway.
    gtype_ = gtk_tree_model_get_type();
  }

  return *this;
}

void TreeModel_Class::iface_init_function(void* g_iface, void*)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_iface);

  //This is just to avoid an "unused variable" warning when there are no vfuncs or signal handlers to connect.
  //This is a temporary fix until I find out why I can not seem to derive a GtkFileChooser interface. murrayc
  g_assert(klass != 0); 

  klass->get_flags = &get_flags_vfunc_callback;
  klass->get_n_columns = &get_n_columns_vfunc_callback;
  klass->get_column_type = &get_column_type_vfunc_callback;
    klass->iter_next = &iter_next_vfunc_callback;
    klass->get_iter = &get_iter_vfunc_callback;
    klass->iter_children = &iter_children_vfunc_callback;
    klass->iter_parent = &iter_parent_vfunc_callback;
    klass->iter_nth_child = &iter_nth_child_vfunc_callback;
    klass->iter_n_children = &iter_n_children_vfunc_callback;
    klass->iter_has_child = &iter_has_child_vfunc_callback;
  klass->ref_node = &ref_node_vfunc_callback;
  klass->unref_node = &unref_node_vfunc_callback;
  klass->get_path = &get_path_vfunc_callback;
  klass->get_value = &get_value_vfunc_callback;
  klass->row_changed = &row_changed_callback;
  klass->row_inserted = &row_inserted_callback;
  klass->row_has_child_toggled = &row_has_child_toggled_callback;
  klass->row_deleted = &row_deleted_callback;
  klass->rows_reordered = &rows_reordered_callback;
}

GtkTreeModelFlags TreeModel_Class::get_flags_vfunc_callback(GtkTreeModel* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return ((GtkTreeModelFlags)(obj->get_flags_vfunc()));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->get_flags)
      return (*base->get_flags)(self);
  }

  typedef GtkTreeModelFlags RType;
  return RType();
}

gint TreeModel_Class::get_n_columns_vfunc_callback(GtkTreeModel* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return obj->get_n_columns_vfunc();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->get_n_columns)
      return (*base->get_n_columns)(self);
  }

  typedef gint RType;
  return RType();
}

GType TreeModel_Class::get_column_type_vfunc_callback(GtkTreeModel* self, gint index)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return obj->get_column_type_vfunc(index
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->get_column_type)
      return (*base->get_column_type)(self, index);
  }

  typedef GType RType;
  return RType();
}

gboolean TreeModel_Class::iter_has_child_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->iter_has_child_vfunc(Gtk::TreeModel::iterator(self, iter)
));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->iter_has_child)
      return (*base->iter_has_child)(self, iter);
  }

  typedef gboolean RType;
  return RType();
}

void TreeModel_Class::ref_node_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->ref_node_vfunc(Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->ref_node)
      (*base->ref_node)(self, iter);
  }
}

void TreeModel_Class::unref_node_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->unref_node_vfunc(Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->unref_node)
      (*base->unref_node)(self, iter);
  }
}

GtkTreePath* TreeModel_Class::get_path_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return (obj->get_path_vfunc(Gtk::TreeModel::iterator(self, iter)
)).gobj_copy();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->get_path)
      return (*base->get_path)(self, iter);
  }

  typedef GtkTreePath* RType;
  return RType();
}

void TreeModel_Class::get_value_vfunc_callback(GtkTreeModel* self, GtkTreeIter* iter, gint column, GValue* value)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->get_value_vfunc(Gtk::TreeModel::iterator(self, iter)
, column
, *reinterpret_cast<Glib::ValueBase*>(value)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->get_value)
      (*base->get_value)(self, iter, column, value);
  }
}


void TreeModel_Class::row_changed_callback(GtkTreeModel* self, GtkTreePath* path, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_row_changed(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->row_changed)
      (*base->row_changed)(self, path, iter);
  }
}

void TreeModel_Class::row_inserted_callback(GtkTreeModel* self, GtkTreePath* path, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_row_inserted(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->row_inserted)
      (*base->row_inserted)(self, path, iter);
  }
}

void TreeModel_Class::row_has_child_toggled_callback(GtkTreeModel* self, GtkTreePath* path, GtkTreeIter* iter)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_row_has_child_toggled(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->row_has_child_toggled)
      (*base->row_has_child_toggled)(self, path, iter);
  }
}

void TreeModel_Class::row_deleted_callback(GtkTreeModel* self, GtkTreePath* path)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_row_deleted(Gtk::TreePath(path, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->row_deleted)
      (*base->row_deleted)(self, path);
  }
}

void TreeModel_Class::rows_reordered_callback(GtkTreeModel* self, GtkTreePath* path, GtkTreeIter* iter, gint* new_order)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_rows_reordered(Gtk::TreePath(path, true)
, Gtk::TreeModel::iterator(self, iter)
, new_order
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(self), CppObjectType::get_type()) // Get the interface.
)    );

    // Call the original underlying C function:
    if(base && base->rows_reordered)
      (*base->rows_reordered)(self, path, iter, new_order);
  }
}


Glib::ObjectBase* TreeModel_Class::wrap_new(GObject* object)
{
  return new TreeModel((GtkTreeModel*)(object));
}


/* The implementation: */

TreeModel::TreeModel()
:
  Glib::Interface(treemodel_class_.init())
{}

TreeModel::TreeModel(GtkTreeModel* castitem)
:
  Glib::Interface((GObject*)(castitem))
{}

TreeModel::~TreeModel()
{}

// static
void TreeModel::add_interface(GType gtype_implementer)
{
  treemodel_class_.init().add_interface(gtype_implementer);
}

TreeModel::CppClassType TreeModel::treemodel_class_; // initialize static member

GType TreeModel::get_type()
{
  return treemodel_class_.init().get_type();
}

GType TreeModel::get_base_type()
{
  return gtk_tree_model_get_type();
}


TreeModelFlags TreeModel::get_flags() const
{
  return ((TreeModelFlags)(gtk_tree_model_get_flags(const_cast<GtkTreeModel*>(gobj()))));
}

int TreeModel::get_n_columns() const
{
  return gtk_tree_model_get_n_columns(const_cast<GtkTreeModel*>(gobj()));
}

GType TreeModel::get_column_type(int index) const
{
  return gtk_tree_model_get_column_type(const_cast<GtkTreeModel*>(gobj()), index);
}

TreeModel::Path TreeModel::get_path(const iterator& iter) const
{
  return Gtk::TreePath(gtk_tree_model_get_path(const_cast<GtkTreeModel*>(gobj()), const_cast<GtkTreeIter*>((iter).gobj())), false);
}

void TreeModel::row_changed(const Path& path, const iterator& iter)
{
  gtk_tree_model_row_changed(gobj(), const_cast<GtkTreePath*>((path).gobj()), const_cast<GtkTreeIter*>((iter).gobj()));
}

void TreeModel::row_inserted(const Path& path, const iterator& iter)
{
  gtk_tree_model_row_inserted(gobj(), const_cast<GtkTreePath*>((path).gobj()), const_cast<GtkTreeIter*>((iter).gobj()));
}

void TreeModel::row_has_child_toggled(const Path& path, const iterator& iter)
{
  gtk_tree_model_row_has_child_toggled(gobj(), const_cast<GtkTreePath*>((path).gobj()), const_cast<GtkTreeIter*>((iter).gobj()));
}

void TreeModel::row_deleted(const Path& path)
{
  gtk_tree_model_row_deleted(gobj(), const_cast<GtkTreePath*>((path).gobj()));
}

void TreeModel::rows_reordered(const Path& path, const iterator& iter, int* new_order)
{
  gtk_tree_model_rows_reordered(gobj(), const_cast<GtkTreePath*>((path).gobj()), const_cast<GtkTreeIter*>((iter).gobj()), new_order);
}

Glib::ustring TreeModel::get_string(const iterator& iter) const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_tree_model_get_string_from_iter(const_cast<GtkTreeModel*>(gobj()), const_cast<GtkTreeIter*>((iter).gobj())));
}


Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& > TreeModel::signal_row_changed()
{
  return Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& >(this, &TreeModel_signal_row_changed_info);
}

Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& > TreeModel::signal_row_inserted()
{
  return Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& >(this, &TreeModel_signal_row_inserted_info);
}

Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& > TreeModel::signal_row_has_child_toggled()
{
  return Glib::SignalProxy2< void,const TreeModel::Path&,const TreeModel::iterator& >(this, &TreeModel_signal_row_has_child_toggled_info);
}

Glib::SignalProxy1< void,const TreeModel::Path& > TreeModel::signal_row_deleted()
{
  return Glib::SignalProxy1< void,const TreeModel::Path& >(this, &TreeModel_signal_row_deleted_info);
}

Glib::SignalProxy3< void,const TreeModel::Path&,const TreeModel::iterator&,int* > TreeModel::signal_rows_reordered()
{
  return Glib::SignalProxy3< void,const TreeModel::Path&,const TreeModel::iterator&,int* >(this, &TreeModel_signal_rows_reordered_info);
}


void Gtk::TreeModel::on_row_changed(const TreeModel::Path& path, const TreeModel::iterator& iter)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->row_changed)
    (*base->row_changed)(gobj(),const_cast<GtkTreePath*>((path).gobj()),const_cast<GtkTreeIter*>((iter).gobj()));
}

void Gtk::TreeModel::on_row_inserted(const TreeModel::Path& path, const TreeModel::iterator& iter)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->row_inserted)
    (*base->row_inserted)(gobj(),const_cast<GtkTreePath*>((path).gobj()),const_cast<GtkTreeIter*>((iter).gobj()));
}

void Gtk::TreeModel::on_row_has_child_toggled(const TreeModel::Path& path, const TreeModel::iterator& iter)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->row_has_child_toggled)
    (*base->row_has_child_toggled)(gobj(),const_cast<GtkTreePath*>((path).gobj()),const_cast<GtkTreeIter*>((iter).gobj()));
}

void Gtk::TreeModel::on_row_deleted(const TreeModel::Path& path)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->row_deleted)
    (*base->row_deleted)(gobj(),const_cast<GtkTreePath*>((path).gobj()));
}

void Gtk::TreeModel::on_rows_reordered(const TreeModel::Path& path, const TreeModel::iterator& iter, int* new_order)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->rows_reordered)
    (*base->rows_reordered)(gobj(),const_cast<GtkTreePath*>((path).gobj()),const_cast<GtkTreeIter*>((iter).gobj()),new_order);
}


TreeModelFlags Gtk::TreeModel::get_flags_vfunc() const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_flags)
    return ((TreeModelFlags)((*base->get_flags)(const_cast<GtkTreeModel*>(gobj()))));

  typedef TreeModelFlags RType;
  return RType();
}

int Gtk::TreeModel::get_n_columns_vfunc() const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_n_columns)
    return (*base->get_n_columns)(const_cast<GtkTreeModel*>(gobj()));

  typedef int RType;
  return RType();
}

GType Gtk::TreeModel::get_column_type_vfunc(int index) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_column_type)
    return (*base->get_column_type)(const_cast<GtkTreeModel*>(gobj()),index);

  typedef GType RType;
  return RType();
}

bool Gtk::TreeModel::iter_has_child_vfunc(const iterator& iter) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->iter_has_child)
    return (*base->iter_has_child)(const_cast<GtkTreeModel*>(gobj()),const_cast<GtkTreeIter*>((iter).gobj()));

  typedef bool RType;
  return RType();
}

void Gtk::TreeModel::ref_node_vfunc(const iterator& iter) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->ref_node)
    (*base->ref_node)(const_cast<GtkTreeModel*>(gobj()),const_cast<GtkTreeIter*>((iter).gobj()));
}

void Gtk::TreeModel::unref_node_vfunc(const iterator& iter) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->unref_node)
    (*base->unref_node)(const_cast<GtkTreeModel*>(gobj()),const_cast<GtkTreeIter*>((iter).gobj()));
}

TreeModel::Path Gtk::TreeModel::get_path_vfunc(const iterator& iter) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_path)
    return Gtk::TreePath((*base->get_path)(const_cast<GtkTreeModel*>(gobj()),const_cast<GtkTreeIter*>((iter).gobj())), false);

  typedef TreeModel::Path RType;
  return RType();
}

void Gtk::TreeModel::get_value_vfunc(const iterator& iter, int column, Glib::ValueBase& value) const
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_interface_peek_parent( // Get the parent interface of the interface (The original underlying C interface).
g_type_interface_peek(G_OBJECT_GET_CLASS(gobject_), CppObjectType::get_type()) // Get the interface.
)  );

  if(base && base->get_value)
    (*base->get_value)(const_cast<GtkTreeModel*>(gobj()),const_cast<GtkTreeIter*>((iter).gobj()),column,(value).gobj());
}


} // namespace Gtk


