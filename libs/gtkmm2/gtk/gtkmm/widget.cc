// Generated by gtkmmproc -- DO NOT MODIFY!

#include <gtkmm/widget.h>
#include <gtkmm/private/widget_p.h>

#include <gtk/gtktypebuiltins.h>
// -*- c++ -*-
/* $Id$ */

/* Copyright 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gtkmm/adjustment.h>
#include <gtkmm/window.h>
#include <gtkmm/accelgroup.h>
#include <gtkmm/settings.h>
#include <gtkmm/style.h>
#include <gtkmm/container.h>
#include <gtkmm/selectiondata_private.h>
#include <gtk/gtkdnd.h>
#include <gtk/gtkselection.h>
#include <gtk/gtkwidget.h>
#include <gtk/gtkcontainer.h>
#include <gtk/gtkmain.h>


namespace //anonymous
{

//These signal callbacks are custom implemented, so that we can create a temporary SelectionData instance.
//To do this, we used the optional custom_c_callback paramater to _WRAP_SIGNAL() in the .hg file.
void Widget_signal_drag_data_get_callback(GtkWidget* self, GdkDragContext* p0,GtkSelectionData* p1,guint p2,guint p3,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>&,SelectionData&,guint,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
      {
        SelectionData_WithoutOwnership temp_instance(p1);
        (*static_cast<SlotType*>(slot))( Glib::wrap(p0, true), temp_instance, p2, p3 );
      }
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

void Widget_signal_selection_get_callback(GtkWidget* self, GtkSelectionData* p0,guint p1,guint p2,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void, SelectionData&, guint, guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
      {
        SelectionData_WithoutOwnership temp_instance(p0);
        (*static_cast<SlotType*>(slot))( temp_instance, p1, p2 );
      }
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}


} //anonymous

namespace Gtk
{

//These default handler callbacks are custom implemented, so that we can create a temporary SelectionData instance.
//To do this, we used the optional custom_c_callback paramater to _WRAP_SIGNAL() in the .hg file.
void Widget_Class::selection_get_callback(GtkWidget* self, GtkSelectionData* p0, guint p1, guint p2)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      SelectionData_WithoutOwnership temp_instance(p0);
      obj->on_selection_get(temp_instance, p1, p2);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->selection_get)
      (*base->selection_get)(self, p0, p1, p2);
  }
}

void Widget_Class::drag_data_get_callback(GtkWidget* self, GdkDragContext* p0, GtkSelectionData* p1, guint p2, guint p3)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      SelectionData_WithoutOwnership temp_instance(p1);
      obj->on_drag_data_get(Glib::wrap(p0, true), temp_instance, p2, p3);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_data_get)
      (*base->drag_data_get)(self, p0, p1, p2, p3);
  }
}

Widget::~Widget()
{}

bool Widget::intersect(const Gdk::Rectangle& area) const
{
  return gtk_widget_intersect(
      const_cast<GtkWidget*>(gobj()), const_cast<GdkRectangle*>(area.gobj()), 0);
}

void Widget::unset_name()
{
  gtk_widget_set_name(gobj(), 0);
}

void Widget::unset_composite_name()
{
  gtk_widget_set_composite_name(gobj(), 0);
}

void Widget::realize_if_needed()
{
  if(!is_realized())
    realize();
}

void Widget::add_modal_grab()
{
  gtk_grab_add(gobj());
}

void Widget::remove_modal_grab()
{
  gtk_grab_remove(gobj());
}

Widget* Widget::get_current_modal_grab()
{
  return Glib::wrap(gtk_grab_get_current());
}

void Widget::path(Glib::ustring& path_arg, Glib::ustring& path_reversed)
{
  guint path_length = 0;
  Glib::ScopedPtr<gchar> path_ptr;
  Glib::ScopedPtr<gchar> rpath_ptr;

  gtk_widget_path(gobj(), &path_length, path_ptr.addr(), rpath_ptr.addr());

  path_arg.assign(path_ptr.get(), path_ptr.get() + path_length);
  path_reversed.assign(rpath_ptr.get(), rpath_ptr.get() + path_length);
}

void Widget::class_path(Glib::ustring& path_arg, Glib::ustring& path_reversed)
{
  guint path_length = 0;
  Glib::ScopedPtr<gchar> path_ptr;
  Glib::ScopedPtr<gchar> rpath_ptr;

  gtk_widget_class_path(gobj(), &path_length, path_ptr.addr(), rpath_ptr.addr());

  path_arg.assign(path_ptr.get(), path_ptr.get() + path_length);
  path_reversed.assign(rpath_ptr.get(), rpath_ptr.get() + path_length);
}

void Widget::modify_bg_pixmap(StateType state, const Glib::ustring& pixmap_name)
{
  const Glib::RefPtr<RcStyle> modifier_style = get_modifier_style();
  modifier_style->set_bg_pixmap_name(state, pixmap_name);
  modify_style(modifier_style);
}

void Widget::unset_fg(StateType state)
{
  gtk_widget_modify_fg(gobj(), static_cast<GtkStateType>(int(state)), 0);
}

void Widget::unset_bg(StateType state)
{
  gtk_widget_modify_bg(gobj(), static_cast<GtkStateType>(int(state)), 0);
}

void Widget::unset_text(StateType state)
{
  gtk_widget_modify_text(gobj(), static_cast<GtkStateType>(int(state)), 0);
}

void Widget::unset_base(StateType state)
{
  gtk_widget_modify_base(gobj(), static_cast<GtkStateType>(int(state)), 0);
}

void Widget::unset_font()
{
  gtk_widget_modify_font(gobj(), 0);
}

bool Widget::is_toplevel() const
  { return GTK_WIDGET_TOPLEVEL(gobj()); }

bool Widget::has_no_window() const
  { return GTK_WIDGET_NO_WINDOW(gobj()); }

bool Widget::is_realized() const
  { return GTK_WIDGET_REALIZED(gobj()); }

bool Widget::is_mapped() const
  { return GTK_WIDGET_MAPPED(gobj()); }

bool Widget::is_visible() const
  { return GTK_WIDGET_VISIBLE(gobj()); }

bool Widget::is_drawable() const
  { return GTK_WIDGET_DRAWABLE(gobj()); }

bool Widget::sensitive() const
  { return GTK_WIDGET_SENSITIVE(gobj()); }

bool Widget::parent_sensitive() const
  { return GTK_WIDGET_PARENT_SENSITIVE(gobj()); }

bool Widget::is_sensitive() const
  { return GTK_WIDGET_IS_SENSITIVE(gobj()); }

bool Widget::can_focus() const
  { return GTK_WIDGET_CAN_FOCUS(gobj()); }

bool Widget::has_focus() const
  { return GTK_WIDGET_HAS_FOCUS(gobj()); }

bool Widget::can_default() const
  { return GTK_WIDGET_CAN_DEFAULT(gobj()); }

bool Widget::has_default() const
  { return GTK_WIDGET_HAS_DEFAULT(gobj()); }

bool Widget::has_grab() const
  { return GTK_WIDGET_HAS_GRAB(gobj()); }

bool Widget::rc_style() const
  { return GTK_WIDGET_RC_STYLE(gobj()); }

bool Widget::is_composite_child() const
  { return GTK_WIDGET_COMPOSITE_CHILD(gobj()); }

bool Widget::app_paintable() const
  { return GTK_WIDGET_APP_PAINTABLE(gobj()); }

bool Widget::receives_default() const
  { return GTK_WIDGET_RECEIVES_DEFAULT(gobj()); }

bool Widget::double_buffered() const
  { return GTK_WIDGET_DOUBLE_BUFFERED(gobj()); }

WidgetFlags Widget::get_flags() const
  { return static_cast<WidgetFlags>(GTK_WIDGET_FLAGS(gobj())); }

void Widget::set_flags(WidgetFlags flags)
  { GTK_WIDGET_SET_FLAGS(gobj(), static_cast<guint32>(flags)); }

void Widget::unset_flags(WidgetFlags flags)
  { GTK_WIDGET_UNSET_FLAGS(gobj(), static_cast<guint32>(flags)); }

int Widget::get_width() const
  { return gobj()->allocation.width; }

int Widget::get_height() const
  { return gobj()->allocation.height; }


void Widget::drag_dest_set(DestDefaults flags, Gdk::DragAction actions)
{
  gtk_drag_dest_set(gobj(), (GtkDestDefaults)flags, 0, 0, (GdkDragAction)actions);
}

void Widget::drag_dest_set(const ArrayHandle_TargetEntry& targets,
                           DestDefaults flags, Gdk::DragAction actions)
{
  // I've used Gdk::ACTION_COPY as the default, because Gdk::ACTION_DEFAULT means that
  // it's never a drag destination, so it would seem like this method didn't work. murrayc.
  gtk_drag_dest_set(
      gobj(), (GtkDestDefaults)flags,
      targets.data(), targets.size(), (GdkDragAction)actions);
}

void Widget::drag_source_set(const ArrayHandle_TargetEntry& targets,
                             Gdk::ModifierType start_button_mask, Gdk::DragAction actions)
{
  // I've used Gdk::MODIFIER_MASK as the default, because it seems
  // to mean 'whatever is possible in the context'. murrayc.
  gtk_drag_source_set(
      gobj(), (GdkModifierType)start_button_mask,
      targets.data(), targets.size(), (GdkDragAction)actions);
}

Widget* Widget::drag_get_source_widget(const Glib::RefPtr<Gdk::DragContext>& context) //static
{
  return Glib::wrap( gtk_drag_get_source_widget(Glib::unwrap(context)) );
}

void Widget::drag_set_as_icon(const Glib::RefPtr<Gdk::DragContext>& context, int hot_x, int hot_y)
{
  gtk_drag_set_icon_widget(Glib::unwrap(context), gobj(), hot_x, hot_y);
}

void Widget_Class::hierarchy_changed_callback_custom(GtkWidget* self, GtkWidget* p0)
{
  //GTKMM_LIFECYCLE
  //Don't call wrap() on a GTK+ instance whose gtkmm instance has been deleted - just call the original C callback.
  bool gtkmm_child_already_deleted = Glib::_gobject_cppinstance_already_deleted((GObject*)p0);

  if(!gtkmm_child_already_deleted)
  {
    //Call the regular, generated callback:
    Widget_Class::hierarchy_changed_callback(self, p0);
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    //Call the original underlying C function:
    if(base && base->hierarchy_changed)
      (*base->hierarchy_changed)(self, p0);
  }
}

void Widget_Class::parent_set_callback_custom(GtkWidget* self, GtkWidget* p0)
{
  //GTKMM_LIFECYCLE
  //Don't call wrap() on a GTK+ instance whose gtkmm instance has been deleted - just call the original C callback.
  bool gtkmm_p0_already_deleted = Glib::_gobject_cppinstance_already_deleted((GObject*)p0);

  if(!gtkmm_p0_already_deleted)
  {
    //Call the regular, generated callback:
    Widget_Class::parent_set_callback(self, p0);
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    //Call the original underlying C function:
    if(base && base->parent_set)
      (*base->parent_set)(self, p0);
  }
}

void Widget_Class::dispose_vfunc_callback(GObject* self)
{
  //Avoid disposal. See also Window_Class::dispose_vfunc_callback().

  #ifdef GLIBMM_DEBUG_REFCOUNTING
  g_warning("Widget_Class::dispose_vfunc_callback(): gobject_: %p\n", (void*)self);
  //if(self)
   //g_warning("  gtypename: %s\n", G_OBJECT_TYPE_NAME(self));
  #endif
  
  Widget *const obj = dynamic_cast<Widget*>(
      Glib::ObjectBase::_get_current_wrapper(self));

  // This function might be invoked recursively because we're triggering
  // several signal emissions, particularly signal_hide().  Therefore we
  // have to test for cpp_destruction_in_progress_ at this point.

  if(obj && !obj->_cpp_destruction_is_in_progress()) //When it should really be destroyed, we zero gobj_.
  { 
    GtkWidget *const pWidget = obj->gobj();
    g_return_if_fail(pWidget == GTK_WIDGET(self));

    // Abort dispose if the widget isn't managed, in order to prevent
    // the nasty self-destroying behaviour of GTK+.  This applies to
    // any widget inside a GtkContainer on gtk_container_destroy()
    // See also Window_Class::dispose_vfunc_callback().
  
    if(obj->referenced_) //Not managed
    { 
      // GTKMM_LIFECYCLE
      // Remove the widget from its parent container so that it
      // won't be destroyed later by gtk_container_destroy().
      if(pWidget->parent)
      {
        // Normally, we would have to ref the child widget because
        // gtk_container_remove() unrefs it.  But since we only remove
        // non-managed objects here, the container just releases the
        // reference it has acquired before in gtk_container_add().

        #ifdef GLIBMM_DEBUG_REFCOUNTING
        g_warning("Widget_Class::dispose_vfunc_callback(): removing gobject_: %p from parent: %p", (void*)self, (void*)pWidget->parent);
        #endif
  
        gtk_container_remove(GTK_CONTAINER(pWidget->parent), pWidget);

        #ifdef GLIBMM_DEBUG_REFCOUNTING
        g_warning("Widget_Class::dispose_vfunc_callback(): after removing from parent.");
        #endif
      }

      #ifdef GLIBMM_DEBUG_REFCOUNTING
      g_warning("Widget_Class::dispose_vfunc_callback(): before gtk_widget_hide().");
      #endif
        
      // Now hide the widget.  The C++ object must _not_ be accessed anymore
      // after this call, because a signal_hide() handler might delete it.
      gtk_widget_hide(pWidget);

      #ifdef GLIBMM_DEBUG_REFCOUNTING
      g_warning("Widget_Class::dispose_vfunc_callback(): after gtk_widget_hide().");
      #endif
      
      // GTKMM_LIFECYCLE
      return; // Prevent calling of normal C dispose vfunc (see below)
    }

    #ifdef GLIBMM_DEBUG_REFCOUNTING
    g_warning("Widget_Class::dispose_vfunc_callback(): unreferenced: before gtk_widget_hide().");
    #endif
    
    // Always hide widgets on gtk_object_destroy(), regardless of whether
    // the widget is managed or not.  This is done for consistency so that
    // connecting to signal_hide() is guaranteed to work.
    gtk_widget_hide(pWidget);

    #ifdef GLIBMM_DEBUG_REFCOUNTING
    g_warning("Widget_Class::dispose_vfunc_callback(): unreferenced:  after gtk_widget_hide().");
    #endif
  }

  GObjectClass *const base = static_cast<GObjectClass*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)));

  #ifdef GLIBMM_DEBUG_REFCOUNTING
  g_warning("Widget_Class::dispose_vfunc_callback(): before calling base->dispose.");
  #endif
        
  if(base->dispose)
    (*base->dispose)(self);

  #ifdef GLIBMM_DEBUG_REFCOUNTING
  g_warning("Widget_Class::dispose_vfunc_callback(): after calling base->dispose.");
  #endif
}


void Widget::unset_style()
{
  gtk_widget_set_style(gobj(), 0 /* See GTK+ docs */);
}

Glib::ustring Widget::drag_dest_find_target(const Glib::RefPtr<Gdk::DragContext>& context) const
{
  return Gdk::AtomString::to_cpp_type(gtk_drag_dest_find_target(const_cast<GtkWidget*>(gobj()), Glib::unwrap(context), 0 /* See GTK+ docs */));
}

void Widget::unset_shape_combine_mask()
{            
  gtk_widget_shape_combine_mask(gobj(), 0, 0, 0); /* See GTK+ docs */
}

void Widget::draw_insertion_cursor(Glib::RefPtr<Gdk::Drawable> drawable, const Gdk::Rectangle& area, const Gdk::Rectangle& location, bool is_primary, TextDirection direction, bool draw_arrow)
{
  gtk_draw_insertion_cursor(gobj(), drawable->gobj(), const_cast<GdkRectangle*>(area.gobj()), const_cast<GdkRectangle*>(location.gobj()), is_primary, (GtkTextDirection)direction, draw_arrow);
}

Requisition Widget::size_request() const
{
  Requisition requisition;
  gtk_widget_size_request(const_cast<GtkWidget*>(gobj()), (GtkRequisition*)(&requisition));
  return requisition;
}


} // namespace Gtk


namespace
{

const Glib::SignalProxyInfo Widget_signal_show_info =
{
  "show",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo Widget_signal_hide_info =
{
  "hide",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo Widget_signal_map_info =
{
  "map",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo Widget_signal_unmap_info =
{
  "unmap",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo Widget_signal_realize_info =
{
  "realize",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


const Glib::SignalProxyInfo Widget_signal_unrealize_info =
{
  "unrealize",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


void Widget_signal_size_request_callback(GtkWidget* self, GtkRequisition* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,Requisition* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))((Requisition*)(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_size_request_info =
{
  "size_request",
  (GCallback) &Widget_signal_size_request_callback,
  (GCallback) &Widget_signal_size_request_callback
};


void Widget_signal_size_allocate_callback(GtkWidget* self, GtkAllocation* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,Allocation& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))((Allocation&)(Glib::wrap(p0))
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_size_allocate_info =
{
  "size_allocate",
  (GCallback) &Widget_signal_size_allocate_callback,
  (GCallback) &Widget_signal_size_allocate_callback
};


void Widget_signal_state_changed_callback(GtkWidget* self, GtkStateType p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,Gtk::StateType > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(((Gtk::StateType)(p0))
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_state_changed_info =
{
  "state_changed",
  (GCallback) &Widget_signal_state_changed_callback,
  (GCallback) &Widget_signal_state_changed_callback
};


void Widget_signal_parent_changed_callback(GtkWidget* self, GtkWidget* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,Widget* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_parent_changed_info =
{
  "parent_set",
  (GCallback) &Widget_signal_parent_changed_callback,
  (GCallback) &Widget_signal_parent_changed_callback
};


void Widget_signal_hierarchy_changed_callback(GtkWidget* self, GtkWidget* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,Widget* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_hierarchy_changed_info =
{
  "hierarchy_changed",
  (GCallback) &Widget_signal_hierarchy_changed_callback,
  (GCallback) &Widget_signal_hierarchy_changed_callback
};


void Widget_signal_style_changed_callback(GtkWidget* self, GtkStyle* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Style>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_style_changed_info =
{
  "style_set",
  (GCallback) &Widget_signal_style_changed_callback,
  (GCallback) &Widget_signal_style_changed_callback
};


void Widget_signal_direction_changed_callback(GtkWidget* self, GtkTextDirection p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,TextDirection > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(((TextDirection)(p0))
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_direction_changed_info =
{
  "direction_changed",
  (GCallback) &Widget_signal_direction_changed_callback,
  (GCallback) &Widget_signal_direction_changed_callback
};


void Widget_signal_grab_notify_callback(GtkWidget* self, gboolean p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,bool > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_grab_notify_info =
{
  "grab_notify",
  (GCallback) &Widget_signal_grab_notify_callback,
  (GCallback) &Widget_signal_grab_notify_callback
};


void Widget_signal_child_notify_callback(GtkWidget* self, GParamSpec* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GParamSpec* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_child_notify_info =
{
  "child_notify",
  (GCallback) &Widget_signal_child_notify_callback,
  (GCallback) &Widget_signal_child_notify_callback
};


gboolean Widget_signal_mnemonic_activate_callback(GtkWidget* self, gboolean p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,bool > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0
));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_mnemonic_activate_notify_callback(GtkWidget* self, gboolean p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,bool > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_mnemonic_activate_info =
{
  "mnemonic_activate",
  (GCallback) &Widget_signal_mnemonic_activate_callback,
  (GCallback) &Widget_signal_mnemonic_activate_notify_callback
};


const Glib::SignalProxyInfo Widget_signal_grab_focus_info =
{
  "grab_focus",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


gboolean Widget_signal_focus_callback(GtkWidget* self, GtkDirectionType p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,DirectionType > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(((DirectionType)(p0))
));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_focus_notify_callback(GtkWidget* self, GtkDirectionType p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,DirectionType > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(((DirectionType)(p0))
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_focus_info =
{
  "focus",
  (GCallback) &Widget_signal_focus_callback,
  (GCallback) &Widget_signal_focus_notify_callback
};


gboolean Widget_signal_event_callback(GtkWidget* self, GdkEvent* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEvent* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_event_notify_callback(GtkWidget* self, GdkEvent* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEvent* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_event_info =
{
  "event",
  (GCallback) &Widget_signal_event_callback,
  (GCallback) &Widget_signal_event_notify_callback
};


void Widget_signal_event_after_callback(GtkWidget* self, GdkEvent* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEvent* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_event_after_info =
{
  "event_after",
  (GCallback) &Widget_signal_event_after_callback,
  (GCallback) &Widget_signal_event_after_callback
};


gboolean Widget_signal_button_press_event_callback(GtkWidget* self, GdkEventButton* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventButton* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_button_press_event_notify_callback(GtkWidget* self, GdkEventButton* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventButton* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_button_press_event_info =
{
  "button_press_event",
  (GCallback) &Widget_signal_button_press_event_callback,
  (GCallback) &Widget_signal_button_press_event_notify_callback
};


gboolean Widget_signal_button_release_event_callback(GtkWidget* self, GdkEventButton* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventButton* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_button_release_event_notify_callback(GtkWidget* self, GdkEventButton* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventButton* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_button_release_event_info =
{
  "button_release_event",
  (GCallback) &Widget_signal_button_release_event_callback,
  (GCallback) &Widget_signal_button_release_event_notify_callback
};


gboolean Widget_signal_scroll_event_callback(GtkWidget* self, GdkEventScroll* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventScroll* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_scroll_event_notify_callback(GtkWidget* self, GdkEventScroll* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventScroll* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_scroll_event_info =
{
  "scroll_event",
  (GCallback) &Widget_signal_scroll_event_callback,
  (GCallback) &Widget_signal_scroll_event_notify_callback
};


gboolean Widget_signal_motion_notify_event_callback(GtkWidget* self, GdkEventMotion* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventMotion* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_motion_notify_event_notify_callback(GtkWidget* self, GdkEventMotion* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventMotion* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_motion_notify_event_info =
{
  "motion_notify_event",
  (GCallback) &Widget_signal_motion_notify_event_callback,
  (GCallback) &Widget_signal_motion_notify_event_notify_callback
};


gboolean Widget_signal_delete_event_callback(GtkWidget* self, GdkEventAny* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_delete_event_notify_callback(GtkWidget* self, GdkEventAny* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_delete_event_info =
{
  "delete_event",
  (GCallback) &Widget_signal_delete_event_callback,
  (GCallback) &Widget_signal_delete_event_notify_callback
};


gboolean Widget_signal_expose_event_callback(GtkWidget* self, GdkEventExpose* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventExpose* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_expose_event_notify_callback(GtkWidget* self, GdkEventExpose* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventExpose* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_expose_event_info =
{
  "expose_event",
  (GCallback) &Widget_signal_expose_event_callback,
  (GCallback) &Widget_signal_expose_event_notify_callback
};


gboolean Widget_signal_key_press_event_callback(GtkWidget* self, GdkEventKey* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventKey* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_key_press_event_notify_callback(GtkWidget* self, GdkEventKey* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventKey* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_key_press_event_info =
{
  "key_press_event",
  (GCallback) &Widget_signal_key_press_event_callback,
  (GCallback) &Widget_signal_key_press_event_notify_callback
};


gboolean Widget_signal_key_release_event_callback(GtkWidget* self, GdkEventKey* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventKey* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_key_release_event_notify_callback(GtkWidget* self, GdkEventKey* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventKey* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_key_release_event_info =
{
  "key_release_event",
  (GCallback) &Widget_signal_key_release_event_callback,
  (GCallback) &Widget_signal_key_release_event_notify_callback
};


gboolean Widget_signal_enter_notify_event_callback(GtkWidget* self, GdkEventCrossing* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventCrossing* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_enter_notify_event_notify_callback(GtkWidget* self, GdkEventCrossing* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventCrossing* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_enter_notify_event_info =
{
  "enter_notify_event",
  (GCallback) &Widget_signal_enter_notify_event_callback,
  (GCallback) &Widget_signal_enter_notify_event_notify_callback
};


gboolean Widget_signal_leave_notify_event_callback(GtkWidget* self, GdkEventCrossing* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventCrossing* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_leave_notify_event_notify_callback(GtkWidget* self, GdkEventCrossing* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventCrossing* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_leave_notify_event_info =
{
  "leave_notify_event",
  (GCallback) &Widget_signal_leave_notify_event_callback,
  (GCallback) &Widget_signal_leave_notify_event_notify_callback
};


gboolean Widget_signal_configure_event_callback(GtkWidget* self, GdkEventConfigure* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventConfigure* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_configure_event_notify_callback(GtkWidget* self, GdkEventConfigure* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventConfigure* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_configure_event_info =
{
  "configure_event",
  (GCallback) &Widget_signal_configure_event_callback,
  (GCallback) &Widget_signal_configure_event_notify_callback
};


gboolean Widget_signal_focus_in_event_callback(GtkWidget* self, GdkEventFocus* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventFocus* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_focus_in_event_notify_callback(GtkWidget* self, GdkEventFocus* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventFocus* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_focus_in_event_info =
{
  "focus_in_event",
  (GCallback) &Widget_signal_focus_in_event_callback,
  (GCallback) &Widget_signal_focus_in_event_notify_callback
};


gboolean Widget_signal_focus_out_event_callback(GtkWidget* self, GdkEventFocus* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventFocus* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_focus_out_event_notify_callback(GtkWidget* self, GdkEventFocus* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventFocus* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_focus_out_event_info =
{
  "focus_out_event",
  (GCallback) &Widget_signal_focus_out_event_callback,
  (GCallback) &Widget_signal_focus_out_event_notify_callback
};


gboolean Widget_signal_map_event_callback(GtkWidget* self, GdkEventAny* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_map_event_notify_callback(GtkWidget* self, GdkEventAny* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_map_event_info =
{
  "map_event",
  (GCallback) &Widget_signal_map_event_callback,
  (GCallback) &Widget_signal_map_event_notify_callback
};


gboolean Widget_signal_unmap_event_callback(GtkWidget* self, GdkEventAny* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_unmap_event_notify_callback(GtkWidget* self, GdkEventAny* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_unmap_event_info =
{
  "unmap_event",
  (GCallback) &Widget_signal_unmap_event_callback,
  (GCallback) &Widget_signal_unmap_event_notify_callback
};


gboolean Widget_signal_property_notify_event_callback(GtkWidget* self, GdkEventProperty* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventProperty* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_property_notify_event_notify_callback(GtkWidget* self, GdkEventProperty* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventProperty* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_property_notify_event_info =
{
  "property_notify_event",
  (GCallback) &Widget_signal_property_notify_event_callback,
  (GCallback) &Widget_signal_property_notify_event_notify_callback
};


gboolean Widget_signal_selection_clear_event_callback(GtkWidget* self, GdkEventSelection* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventSelection* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_selection_clear_event_notify_callback(GtkWidget* self, GdkEventSelection* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventSelection* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_selection_clear_event_info =
{
  "selection_clear_event",
  (GCallback) &Widget_signal_selection_clear_event_callback,
  (GCallback) &Widget_signal_selection_clear_event_notify_callback
};


gboolean Widget_signal_selection_request_event_callback(GtkWidget* self, GdkEventSelection* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventSelection* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_selection_request_event_notify_callback(GtkWidget* self, GdkEventSelection* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventSelection* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_selection_request_event_info =
{
  "selection_request_event",
  (GCallback) &Widget_signal_selection_request_event_callback,
  (GCallback) &Widget_signal_selection_request_event_notify_callback
};


gboolean Widget_signal_selection_notify_event_callback(GtkWidget* self, GdkEventSelection* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventSelection* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_selection_notify_event_notify_callback(GtkWidget* self, GdkEventSelection* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventSelection* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_selection_notify_event_info =
{
  "selection_notify_event",
  (GCallback) &Widget_signal_selection_notify_event_callback,
  (GCallback) &Widget_signal_selection_notify_event_notify_callback
};


gboolean Widget_signal_proximity_in_event_callback(GtkWidget* self, GdkEventProximity* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventProximity* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_proximity_in_event_notify_callback(GtkWidget* self, GdkEventProximity* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventProximity* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_proximity_in_event_info =
{
  "proximity_in_event",
  (GCallback) &Widget_signal_proximity_in_event_callback,
  (GCallback) &Widget_signal_proximity_in_event_notify_callback
};


gboolean Widget_signal_proximity_out_event_callback(GtkWidget* self, GdkEventProximity* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventProximity* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_proximity_out_event_notify_callback(GtkWidget* self, GdkEventProximity* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventProximity* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_proximity_out_event_info =
{
  "proximity_out_event",
  (GCallback) &Widget_signal_proximity_out_event_callback,
  (GCallback) &Widget_signal_proximity_out_event_notify_callback
};


gboolean Widget_signal_visibility_notify_event_callback(GtkWidget* self, GdkEventVisibility* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventVisibility* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_visibility_notify_event_notify_callback(GtkWidget* self, GdkEventVisibility* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventVisibility* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_visibility_notify_event_info =
{
  "visibility_notify_event",
  (GCallback) &Widget_signal_visibility_notify_event_callback,
  (GCallback) &Widget_signal_visibility_notify_event_notify_callback
};


gboolean Widget_signal_client_event_callback(GtkWidget* self, GdkEventClient* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventClient* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_client_event_notify_callback(GtkWidget* self, GdkEventClient* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventClient* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_client_event_info =
{
  "client_event",
  (GCallback) &Widget_signal_client_event_callback,
  (GCallback) &Widget_signal_client_event_notify_callback
};


gboolean Widget_signal_no_expose_event_callback(GtkWidget* self, GdkEventAny* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_no_expose_event_notify_callback(GtkWidget* self, GdkEventAny* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventAny* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_no_expose_event_info =
{
  "no_expose_event",
  (GCallback) &Widget_signal_no_expose_event_callback,
  (GCallback) &Widget_signal_no_expose_event_notify_callback
};


gboolean Widget_signal_window_state_event_callback(GtkWidget* self, GdkEventWindowState* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,GdkEventWindowState* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_window_state_event_notify_callback(GtkWidget* self, GdkEventWindowState* p0, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,GdkEventWindowState* > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_window_state_event_info =
{
  "window_state_event",
  (GCallback) &Widget_signal_window_state_event_callback,
  (GCallback) &Widget_signal_window_state_event_notify_callback
};


const Glib::SignalProxyInfo Widget_signal_selection_get_info =
{
  "selection_get",
  (GCallback) &Widget_signal_selection_get_callback,
  (GCallback) &Widget_signal_selection_get_callback
};


void Widget_signal_selection_received_callback(GtkWidget* self, GtkSelectionData* p0,guint p1,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const SelectionData&,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(SelectionData_WithoutOwnership(p0)
, p1);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_selection_received_info =
{
  "selection_received",
  (GCallback) &Widget_signal_selection_received_callback,
  (GCallback) &Widget_signal_selection_received_callback
};


void Widget_signal_drag_begin_callback(GtkWidget* self, GdkDragContext* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_drag_begin_info =
{
  "drag_begin",
  (GCallback) &Widget_signal_drag_begin_callback,
  (GCallback) &Widget_signal_drag_begin_callback
};


void Widget_signal_drag_end_callback(GtkWidget* self, GdkDragContext* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_drag_end_info =
{
  "drag_end",
  (GCallback) &Widget_signal_drag_end_callback,
  (GCallback) &Widget_signal_drag_end_callback
};


const Glib::SignalProxyInfo Widget_signal_drag_data_get_info =
{
  "drag_data_get",
  (GCallback) &Widget_signal_drag_data_get_callback,
  (GCallback) &Widget_signal_drag_data_get_callback
};


void Widget_signal_drag_data_delete_callback(GtkWidget* self, GdkDragContext* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_drag_data_delete_info =
{
  "drag_data_delete",
  (GCallback) &Widget_signal_drag_data_delete_callback,
  (GCallback) &Widget_signal_drag_data_delete_callback
};


void Widget_signal_drag_leave_callback(GtkWidget* self, GdkDragContext* p0,guint p1,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>&,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
, p1);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_drag_leave_info =
{
  "drag_leave",
  (GCallback) &Widget_signal_drag_leave_callback,
  (GCallback) &Widget_signal_drag_leave_callback
};


gboolean Widget_signal_drag_motion_callback(GtkWidget* self, GdkDragContext* p0,gint p1,gint p2,guint p3,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
, p1
, p2
, p3));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_drag_motion_notify_callback(GtkWidget* self, GdkDragContext* p0,gint p1,gint p2,guint p3, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
, p1
, p2
, p3);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_drag_motion_info =
{
  "drag_motion",
  (GCallback) &Widget_signal_drag_motion_callback,
  (GCallback) &Widget_signal_drag_motion_notify_callback
};


gboolean Widget_signal_drag_drop_callback(GtkWidget* self, GdkDragContext* p0,gint p1,gint p2,guint p3,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
, p1
, p2
, p3));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_signal_drag_drop_notify_callback(GtkWidget* self, GdkDragContext* p0,gint p1,gint p2,guint p3, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
, p1
, p2
, p3);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef gboolean RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_drag_drop_info =
{
  "drag_drop",
  (GCallback) &Widget_signal_drag_drop_callback,
  (GCallback) &Widget_signal_drag_drop_notify_callback
};


void Widget_signal_drag_data_received_callback(GtkWidget* self, GdkDragContext* p0,gint p1,gint p2,GtkSelectionData* p3,guint p4,guint p5,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::DragContext>&,int,int,const SelectionData&,guint,guint > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
, p1
, p2
, SelectionData_WithoutOwnership(p3)
, p4, p5);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_drag_data_received_info =
{
  "drag_data_received",
  (GCallback) &Widget_signal_drag_data_received_callback,
  (GCallback) &Widget_signal_drag_data_received_callback
};


AtkObject* Widget_signal_get_accessible_callback(GtkWidget* self, void* data)
{
  using namespace Gtk;
  typedef sigc::slot< Glib::RefPtr<Atk::Object> > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        return Glib::unwrap((*static_cast<SlotType*>(slot))());
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef AtkObject* RType;
  return RType();
}

AtkObject* Widget_signal_get_accessible_notify_callback(GtkWidget* self,  void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }

  typedef AtkObject* RType;
  return RType();
}

const Glib::SignalProxyInfo Widget_signal_get_accessible_info =
{
  "get_accessible",
  (GCallback) &Widget_signal_get_accessible_callback,
  (GCallback) &Widget_signal_get_accessible_notify_callback
};


void Widget_signal_screen_changed_callback(GtkWidget* self, GdkScreen* p0,void* data)
{
  using namespace Gtk;
  typedef sigc::slot< void,const Glib::RefPtr<Gdk::Screen>& > SlotType;

  // Do not try to call a signal on a disassociated wrapper.
  if(Glib::ObjectBase::_get_current_wrapper((GObject*) self))
  {
    try
    {
      if(sigc::slot_base *const slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo Widget_signal_screen_changed_info =
{
  "screen_changed",
  (GCallback) &Widget_signal_screen_changed_callback,
  (GCallback) &Widget_signal_screen_changed_callback
};

} // anonymous namespace

// static
GType Glib::Value<Gtk::DestDefaults>::value_type()
{
  return gtk_dest_defaults_get_type();
}

// static
GType Glib::Value<Gtk::WidgetFlags>::value_type()
{
  return gtk_widget_flags_get_type();
}

// static
GType Glib::Value<Gtk::WidgetHelpType>::value_type()
{
  return gtk_widget_help_type_get_type();
}


namespace Glib
{

Gtk::Widget* wrap(GtkWidget* object, bool take_copy)
{
  return dynamic_cast<Gtk::Widget *> (Glib::wrap_auto ((GObject*)(object), take_copy));
}

} /* namespace Glib */

namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& Widget_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Widget_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_widget_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:
  Atk::Implementor::add_interface(get_type());
  }

  return *this;
}

void Widget_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

    reinterpret_cast<GObjectClass*>(klass)->dispose = &dispose_vfunc_callback;
    klass->dispatch_child_properties_changed = &dispatch_child_properties_changed_vfunc_callback;
  klass->show_all = &show_all_vfunc_callback;
  klass->hide_all = &hide_all_vfunc_callback;
  klass->get_accessible = &get_accessible_vfunc_callback;
  klass->show = &show_callback;
  klass->hide = &hide_callback;
  klass->map = &map_callback;
  klass->unmap = &unmap_callback;
  klass->realize = &realize_callback;
  klass->unrealize = &unrealize_callback;
  klass->size_request = &size_request_callback;
  klass->size_allocate = &size_allocate_callback;
  klass->state_changed = &state_changed_callback;
  klass->parent_set = &parent_set_callback;
  klass->hierarchy_changed = &hierarchy_changed_callback;
  klass->style_set = &style_set_callback;
  klass->direction_changed = &direction_changed_callback;
  klass->grab_notify = &grab_notify_callback;
  klass->child_notify = &child_notify_callback;
  klass->mnemonic_activate = &mnemonic_activate_callback;
  klass->grab_focus = &grab_focus_callback;
  klass->focus = &focus_callback;
  klass->event = &event_callback;
  klass->button_press_event = &button_press_event_callback;
  klass->button_release_event = &button_release_event_callback;
  klass->scroll_event = &scroll_event_callback;
  klass->motion_notify_event = &motion_notify_event_callback;
  klass->delete_event = &delete_event_callback;
  klass->expose_event = &expose_event_callback;
  klass->key_press_event = &key_press_event_callback;
  klass->key_release_event = &key_release_event_callback;
  klass->enter_notify_event = &enter_notify_event_callback;
  klass->leave_notify_event = &leave_notify_event_callback;
  klass->configure_event = &configure_event_callback;
  klass->focus_in_event = &focus_in_event_callback;
  klass->focus_out_event = &focus_out_event_callback;
  klass->map_event = &map_event_callback;
  klass->unmap_event = &unmap_event_callback;
  klass->property_notify_event = &property_notify_event_callback;
  klass->selection_clear_event = &selection_clear_event_callback;
  klass->selection_request_event = &selection_request_event_callback;
  klass->selection_notify_event = &selection_notify_event_callback;
  klass->proximity_in_event = &proximity_in_event_callback;
  klass->proximity_out_event = &proximity_out_event_callback;
  klass->visibility_notify_event = &visibility_notify_event_callback;
  klass->client_event = &client_event_callback;
  klass->no_expose_event = &no_expose_event_callback;
  klass->window_state_event = &window_state_event_callback;
  klass->selection_get = &selection_get_callback;
  klass->selection_received = &selection_received_callback;
  klass->drag_begin = &drag_begin_callback;
  klass->drag_end = &drag_end_callback;
  klass->drag_data_get = &drag_data_get_callback;
  klass->drag_data_delete = &drag_data_delete_callback;
  klass->drag_leave = &drag_leave_callback;
  klass->drag_motion = &drag_motion_callback;
  klass->drag_drop = &drag_drop_callback;
  klass->drag_data_received = &drag_data_received_callback;
  klass->get_accessible = &get_accessible_callback;
  klass->screen_changed = &screen_changed_callback;
    klass->hierarchy_changed = &hierarchy_changed_callback_custom;
      klass->parent_set = &parent_set_callback_custom;
  }

void Widget_Class::dispatch_child_properties_changed_vfunc_callback(GtkWidget* self, guint n_pspecs, GParamSpec** pspecs)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->dispatch_child_properties_changed_vfunc(n_pspecs, pspecs);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->dispatch_child_properties_changed)
      (*base->dispatch_child_properties_changed)(self, n_pspecs, pspecs);
  }
}

void Widget_Class::show_all_vfunc_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->show_all_vfunc();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->show_all)
      (*base->show_all)(self);
  }
}

void Widget_Class::hide_all_vfunc_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->hide_all_vfunc();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->hide_all)
      (*base->hide_all)(self);
  }
}

AtkObject* Widget_Class::get_accessible_vfunc_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return Glib::unwrap(obj->get_accessible_vfunc());
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->get_accessible)
      return (*base->get_accessible)(self);
  }

  typedef AtkObject* RType;
  return RType();
}


void Widget_Class::show_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_show();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->show)
      (*base->show)(self);
  }
}

void Widget_Class::hide_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_hide();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->hide)
      (*base->hide)(self);
  }
}

void Widget_Class::map_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_map();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->map)
      (*base->map)(self);
  }
}

void Widget_Class::unmap_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_unmap();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->unmap)
      (*base->unmap)(self);
  }
}

void Widget_Class::realize_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_realize();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->realize)
      (*base->realize)(self);
  }
}

void Widget_Class::unrealize_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_unrealize();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->unrealize)
      (*base->unrealize)(self);
  }
}

void Widget_Class::size_request_callback(GtkWidget* self, GtkRequisition* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_size_request((Requisition*)(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->size_request)
      (*base->size_request)(self, p0);
  }
}

void Widget_Class::size_allocate_callback(GtkWidget* self, GtkAllocation* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_size_allocate((Allocation&)(Glib::wrap(p0))
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->size_allocate)
      (*base->size_allocate)(self, p0);
  }
}

void Widget_Class::state_changed_callback(GtkWidget* self, GtkStateType p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_state_changed(((Gtk::StateType)(p0))
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->state_changed)
      (*base->state_changed)(self, p0);
  }
}

void Widget_Class::parent_set_callback(GtkWidget* self, GtkWidget* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_parent_changed(Glib::wrap(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->parent_set)
      (*base->parent_set)(self, p0);
  }
}

void Widget_Class::hierarchy_changed_callback(GtkWidget* self, GtkWidget* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_hierarchy_changed(Glib::wrap(p0)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->hierarchy_changed)
      (*base->hierarchy_changed)(self, p0);
  }
}

void Widget_Class::style_set_callback(GtkWidget* self, GtkStyle* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_style_changed(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->style_set)
      (*base->style_set)(self, p0);
  }
}

void Widget_Class::direction_changed_callback(GtkWidget* self, GtkTextDirection p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_direction_changed(((TextDirection)(p0))
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->direction_changed)
      (*base->direction_changed)(self, p0);
  }
}

void Widget_Class::grab_notify_callback(GtkWidget* self, gboolean p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_grab_notify(p0
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->grab_notify)
      (*base->grab_notify)(self, p0);
  }
}

void Widget_Class::child_notify_callback(GtkWidget* self, GParamSpec* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_child_notify(p0);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->child_notify)
      (*base->child_notify)(self, p0);
  }
}

gboolean Widget_Class::mnemonic_activate_callback(GtkWidget* self, gboolean p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_mnemonic_activate(p0
));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->mnemonic_activate)
      return (*base->mnemonic_activate)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

void Widget_Class::grab_focus_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_grab_focus();
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->grab_focus)
      (*base->grab_focus)(self);
  }
}

gboolean Widget_Class::focus_callback(GtkWidget* self, GtkDirectionType p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_focus(((DirectionType)(p0))
));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->focus)
      return (*base->focus)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::event_callback(GtkWidget* self, GdkEvent* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->event)
      return (*base->event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::button_press_event_callback(GtkWidget* self, GdkEventButton* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_button_press_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->button_press_event)
      return (*base->button_press_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::button_release_event_callback(GtkWidget* self, GdkEventButton* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_button_release_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->button_release_event)
      return (*base->button_release_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::scroll_event_callback(GtkWidget* self, GdkEventScroll* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_scroll_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->scroll_event)
      return (*base->scroll_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::motion_notify_event_callback(GtkWidget* self, GdkEventMotion* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_motion_notify_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->motion_notify_event)
      return (*base->motion_notify_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::delete_event_callback(GtkWidget* self, GdkEventAny* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_delete_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->delete_event)
      return (*base->delete_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::expose_event_callback(GtkWidget* self, GdkEventExpose* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_expose_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->expose_event)
      return (*base->expose_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::key_press_event_callback(GtkWidget* self, GdkEventKey* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_key_press_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->key_press_event)
      return (*base->key_press_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::key_release_event_callback(GtkWidget* self, GdkEventKey* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_key_release_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->key_release_event)
      return (*base->key_release_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::enter_notify_event_callback(GtkWidget* self, GdkEventCrossing* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_enter_notify_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->enter_notify_event)
      return (*base->enter_notify_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::leave_notify_event_callback(GtkWidget* self, GdkEventCrossing* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_leave_notify_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->leave_notify_event)
      return (*base->leave_notify_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::configure_event_callback(GtkWidget* self, GdkEventConfigure* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_configure_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->configure_event)
      return (*base->configure_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::focus_in_event_callback(GtkWidget* self, GdkEventFocus* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_focus_in_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->focus_in_event)
      return (*base->focus_in_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::focus_out_event_callback(GtkWidget* self, GdkEventFocus* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_focus_out_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->focus_out_event)
      return (*base->focus_out_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::map_event_callback(GtkWidget* self, GdkEventAny* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_map_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->map_event)
      return (*base->map_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::unmap_event_callback(GtkWidget* self, GdkEventAny* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_unmap_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->unmap_event)
      return (*base->unmap_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::property_notify_event_callback(GtkWidget* self, GdkEventProperty* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_property_notify_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->property_notify_event)
      return (*base->property_notify_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::selection_clear_event_callback(GtkWidget* self, GdkEventSelection* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_selection_clear_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->selection_clear_event)
      return (*base->selection_clear_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::selection_request_event_callback(GtkWidget* self, GdkEventSelection* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_selection_request_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->selection_request_event)
      return (*base->selection_request_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::selection_notify_event_callback(GtkWidget* self, GdkEventSelection* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_selection_notify_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->selection_notify_event)
      return (*base->selection_notify_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::proximity_in_event_callback(GtkWidget* self, GdkEventProximity* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_proximity_in_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->proximity_in_event)
      return (*base->proximity_in_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::proximity_out_event_callback(GtkWidget* self, GdkEventProximity* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_proximity_out_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->proximity_out_event)
      return (*base->proximity_out_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::visibility_notify_event_callback(GtkWidget* self, GdkEventVisibility* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_visibility_notify_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->visibility_notify_event)
      return (*base->visibility_notify_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::client_event_callback(GtkWidget* self, GdkEventClient* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_client_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->client_event)
      return (*base->client_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::no_expose_event_callback(GtkWidget* self, GdkEventAny* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_no_expose_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->no_expose_event)
      return (*base->no_expose_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::window_state_event_callback(GtkWidget* self, GdkEventWindowState* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_window_state_event(p0));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->window_state_event)
      return (*base->window_state_event)(self, p0);
  }

  typedef gboolean RType;
  return RType();
}

void Widget_Class::selection_received_callback(GtkWidget* self, GtkSelectionData* p0, guint p1)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_selection_received(SelectionData_WithoutOwnership(p0)
, p1);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->selection_received)
      (*base->selection_received)(self, p0, p1);
  }
}

void Widget_Class::drag_begin_callback(GtkWidget* self, GdkDragContext* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_drag_begin(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_begin)
      (*base->drag_begin)(self, p0);
  }
}

void Widget_Class::drag_end_callback(GtkWidget* self, GdkDragContext* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_drag_end(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_end)
      (*base->drag_end)(self, p0);
  }
}

void Widget_Class::drag_data_delete_callback(GtkWidget* self, GdkDragContext* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_drag_data_delete(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_data_delete)
      (*base->drag_data_delete)(self, p0);
  }
}

void Widget_Class::drag_leave_callback(GtkWidget* self, GdkDragContext* p0, guint p1)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_drag_leave(Glib::wrap(p0, true)
, p1);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_leave)
      (*base->drag_leave)(self, p0, p1);
  }
}

gboolean Widget_Class::drag_motion_callback(GtkWidget* self, GdkDragContext* p0, gint p1, gint p2, guint p3)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_drag_motion(Glib::wrap(p0, true)
, p1
, p2
, p3));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_motion)
      return (*base->drag_motion)(self, p0, p1, p2, p3);
  }

  typedef gboolean RType;
  return RType();
}

gboolean Widget_Class::drag_drop_callback(GtkWidget* self, GdkDragContext* p0, gint p1, gint p2, guint p3)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return static_cast<int>(obj->on_drag_drop(Glib::wrap(p0, true)
, p1
, p2
, p3));
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_drop)
      return (*base->drag_drop)(self, p0, p1, p2, p3);
  }

  typedef gboolean RType;
  return RType();
}

void Widget_Class::drag_data_received_callback(GtkWidget* self, GdkDragContext* p0, gint p1, gint p2, GtkSelectionData* p3, guint p4, guint p5)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_drag_data_received(Glib::wrap(p0, true)
, p1
, p2
, SelectionData_WithoutOwnership(p3)
, p4, p5);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->drag_data_received)
      (*base->drag_data_received)(self, p0, p1, p2, p3, p4, p5);
  }
}

AtkObject* Widget_Class::get_accessible_callback(GtkWidget* self)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      return Glib::unwrap(obj->on_get_accessible());
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->get_accessible)
      return (*base->get_accessible)(self);
  }

  typedef AtkObject* RType;
  return RType();
}

void Widget_Class::screen_changed_callback(GtkWidget* self, GdkScreen* p0)
{
  CppObjectType *const obj = dynamic_cast<CppObjectType*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj && obj->is_derived_())
  {
    try // Trap C++ exceptions which would normally be lost because this is a C callback.
    {
      // Call the virtual member method, which derived classes might override.
      obj->on_screen_changed(Glib::wrap(p0, true)
);
    }
    catch(...)
    {
      Glib::exception_handlers_invoke();
    }
  }
  else
  {
    BaseClassType *const base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

    // Call the original underlying C function:
    if(base && base->screen_changed)
      (*base->screen_changed)(self, p0);
  }
}


Glib::ObjectBase* Widget_Class::wrap_new(GObject* o)
{
  return manage(new Widget((GtkWidget*)(o)));

}


/* The implementation: */

Widget::Widget(const Glib::ConstructParams& construct_params)
:
  Gtk::Object(construct_params)
{
  }

Widget::Widget(GtkWidget* castitem)
:
  Gtk::Object((GtkObject*)(castitem))
{
  }

Widget::CppClassType Widget::widget_class_; // initialize static member

GType Widget::get_type()
{
  return widget_class_.init().get_type();
}

GType Widget::get_base_type()
{
  return gtk_widget_get_type();
}


bool Widget::set_scroll_adjustments(Adjustment& hadjustment, Adjustment& vadjustment)
{
  return gtk_widget_set_scroll_adjustments(gobj(), (hadjustment).gobj(), (vadjustment).gobj());
}

void Widget::show()
{
  gtk_widget_show(gobj());
}

void Widget::show_now()
{
  gtk_widget_show_now(gobj());
}

void Widget::hide()
{
  gtk_widget_hide(gobj());
}

void Widget::show_all()
{
  gtk_widget_show_all(gobj());
}

void Widget::hide_all()
{
  gtk_widget_hide_all(gobj());
}

void Widget::queue_draw()
{
  gtk_widget_queue_draw(gobj());
}

void Widget::queue_draw_area(int x, int y, int width, int height)
{
  gtk_widget_queue_draw_area(gobj(), x, y, width, height);
}

void Widget::queue_resize()
{
  gtk_widget_queue_resize(gobj());
}

void Widget::size_request(const Requisition& requisition)
{
  gtk_widget_size_request(gobj(), (GtkRequisition*)(&requisition));
}

void Widget::size_allocate(const Allocation& allocation)
{
  gtk_widget_size_allocate(gobj(), (GtkAllocation*)(allocation.gobj()));
}

void Widget::add_accelerator(const Glib::ustring& accel_signal, const Glib::RefPtr<AccelGroup>& accel_group, guint accel_key, Gdk::ModifierType accel_mods, AccelFlags accel_flags)
{
  gtk_widget_add_accelerator(gobj(), accel_signal.c_str(), Glib::unwrap(accel_group), accel_key, ((GdkModifierType)(accel_mods)), ((GtkAccelFlags)(accel_flags)));
}

bool Widget::remove_accelerator(const Glib::RefPtr<AccelGroup>& accel_group, guint accel_key, Gdk::ModifierType accel_mods)
{
  return gtk_widget_remove_accelerator(gobj(), Glib::unwrap(accel_group), accel_key, ((GdkModifierType)(accel_mods)));
}

void Widget::set_accel_path(const Glib::ustring& accel_path, const Glib::RefPtr<AccelGroup>& accel_group)
{
  gtk_widget_set_accel_path(gobj(), accel_path.c_str(), Glib::unwrap(accel_group));
}

bool Widget::mnemonic_activate(bool group_cycling)
{
  return gtk_widget_mnemonic_activate(gobj(), static_cast<int>(group_cycling));
}

bool Widget::event(GdkEvent* event)
{
  return gtk_widget_event(gobj(), event);
}

int Widget::send_expose(GdkEvent* event)
{
  return gtk_widget_send_expose(gobj(), event);
}

bool Widget::activate()
{
  return gtk_widget_activate(gobj());
}

void Widget::reparent(Widget & new_parent)
{
  gtk_widget_reparent(gobj(), (new_parent).gobj());
}

bool Widget::intersect(const Gdk::Rectangle& area, Gdk::Rectangle& intersection) const
{
  return gtk_widget_intersect(const_cast<GtkWidget*>(gobj()), const_cast<GdkRectangle*>(area.gobj()), (intersection).gobj());
}

Gdk::Region Widget::region_intersect(const Gdk::Region& region) const
{
  return Gdk::Region(gtk_widget_region_intersect(const_cast<GtkWidget*>(gobj()), const_cast<GdkRegion*>((region).gobj())));
}

void Widget::freeze_child_notify()
{
  gtk_widget_freeze_child_notify(gobj());
}

void Widget::child_notify(const Glib::ustring& child_property)
{
  gtk_widget_child_notify(gobj(), child_property.c_str());
}

void Widget::thaw_child_notify()
{
  gtk_widget_thaw_child_notify(gobj());
}

bool Widget::is_focus() const
{
  return gtk_widget_is_focus(const_cast<GtkWidget*>(gobj()));
}

void Widget::grab_focus()
{
  gtk_widget_grab_focus(gobj());
}

void Widget::grab_default()
{
  gtk_widget_grab_default(gobj());
}

void Widget::set_name(const Glib::ustring& name)
{
  gtk_widget_set_name(gobj(), name.c_str());
}

Glib::ustring Widget::get_name() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(gtk_widget_get_name(const_cast<GtkWidget*>(gobj())));
}

void Widget::set_state(Gtk::StateType state)
{
  gtk_widget_set_state(gobj(), ((GtkStateType)(state)));
}

void Widget::set_sensitive(bool sensitive)
{
  gtk_widget_set_sensitive(gobj(), static_cast<int>(sensitive));
}

void Widget::set_app_paintable(bool app_paintable)
{
  gtk_widget_set_app_paintable(gobj(), static_cast<int>(app_paintable));
}

void Widget::set_double_buffered(bool double_buffered)
{
  gtk_widget_set_double_buffered(gobj(), static_cast<int>(double_buffered));
}

void Widget::set_redraw_on_allocate(bool redraw_on_allocate)
{
  gtk_widget_set_redraw_on_allocate(gobj(), static_cast<int>(redraw_on_allocate));
}

void Widget::set_child_visible(bool is_visible)
{
  gtk_widget_set_child_visible(gobj(), static_cast<int>(is_visible));
}

bool Widget::get_child_visible() const
{
  return gtk_widget_get_child_visible(const_cast<GtkWidget*>(gobj()));
}

Container* Widget::get_parent()
{
  return Glib::wrap((GtkContainer*)(gtk_widget_get_parent(gobj())));
}

const Container* Widget::get_parent() const
{
  return Glib::wrap((GtkContainer*)(gtk_widget_get_parent(const_cast<GtkWidget*>(gobj()))));
}

Glib::RefPtr<Gdk::Window> Widget::get_parent_window()
{

  Glib::RefPtr<Gdk::Window> retvalue = Glib::wrap((GdkWindowObject*)(gtk_widget_get_parent_window(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Gdk::Window> Widget::get_parent_window() const
{

  Glib::RefPtr<const Gdk::Window> retvalue = Glib::wrap((GdkWindowObject*)(gtk_widget_get_parent_window(const_cast<GtkWidget*>(gobj()))));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

void Widget::set_parent_window(const Glib::RefPtr<const Gdk::Window>& parent_window)
{
  gtk_widget_set_parent_window(gobj(), const_cast<GdkWindow*>(Glib::unwrap<Gdk::Window>(parent_window)));
}

bool Widget::child_focus(DirectionType direction)
{
  return gtk_widget_child_focus(gobj(), ((GtkDirectionType)(direction)));
}

void Widget::set_size_request(int width, int height)
{
  gtk_widget_set_size_request(gobj(), width, height);
}

void Widget::get_size_request(int& width, int& height) const
{
  gtk_widget_get_size_request(const_cast<GtkWidget*>(gobj()), &width, &height);
}

void Widget::set_events(Gdk::EventMask events)
{
  gtk_widget_set_events(gobj(), events);
}

void Widget::add_events(Gdk::EventMask events)
{
  gtk_widget_add_events(gobj(), events);
}

void Widget::set_extension_events(Gdk::ExtensionMode mode)
{
  gtk_widget_set_extension_events(gobj(), ((GdkExtensionMode)(mode)));
}

Gdk::ExtensionMode Widget::get_extension_events() const
{
  return ((Gdk::ExtensionMode)(gtk_widget_get_extension_events(const_cast<GtkWidget*>(gobj()))));
}

Container* Widget::get_toplevel()
{
  return Glib::wrap((GtkContainer*)(gtk_widget_get_toplevel(gobj())));
}

const Container* Widget::get_toplevel() const
{
  return Glib::wrap((GtkContainer*)(gtk_widget_get_toplevel(const_cast<GtkWidget*>(gobj()))));
}

Widget* Widget::get_ancestor(GType widget_type)
{
  return Glib::wrap(gtk_widget_get_ancestor(gobj(), widget_type));
}

const Widget* Widget::get_ancestor(GType widget_type) const
{
  return Glib::wrap(gtk_widget_get_ancestor(const_cast<GtkWidget*>(gobj()), widget_type));
}

Glib::RefPtr<Gdk::Colormap> Widget::get_colormap()
{

  Glib::RefPtr<Gdk::Colormap> retvalue = Glib::wrap(gtk_widget_get_colormap(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Gdk::Visual> Widget::get_visual()
{

  Glib::RefPtr<Gdk::Visual> retvalue = Glib::wrap(gtk_widget_get_visual(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Gdk::Screen> Widget::get_screen()
{

  Glib::RefPtr<Gdk::Screen> retvalue = Glib::wrap(gtk_widget_get_screen(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Gdk::Screen> Widget::get_screen() const
{

  Glib::RefPtr<const Gdk::Screen> retvalue = Glib::wrap(gtk_widget_get_screen(const_cast<GtkWidget*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

bool Widget::has_screen() const
{
  return gtk_widget_has_screen(const_cast<GtkWidget*>(gobj()));
}

Glib::RefPtr<Gdk::Display> Widget::get_display()
{

  Glib::RefPtr<Gdk::Display> retvalue = Glib::wrap(gtk_widget_get_display(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Gdk::Display> Widget::get_display() const
{

  Glib::RefPtr<const Gdk::Display> retvalue = Glib::wrap(gtk_widget_get_display(const_cast<GtkWidget*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Gdk::Window> Widget::get_root_window()
{

  Glib::RefPtr<Gdk::Window> retvalue = Glib::wrap((GdkWindowObject*)(gtk_widget_get_root_window(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Gdk::Window> Widget::get_root_window() const
{

  Glib::RefPtr<const Gdk::Window> retvalue = Glib::wrap((GdkWindowObject*)(gtk_widget_get_root_window(const_cast<GtkWidget*>(gobj()))));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Settings> Widget::get_settings()
{

  Glib::RefPtr<Settings> retvalue = Glib::wrap(gtk_widget_get_settings(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Clipboard> Widget::get_clipboard(const Glib::ustring& selection)
{

  Glib::RefPtr<Clipboard> retvalue = Glib::wrap(gtk_widget_get_clipboard(gobj(), Gdk::AtomString::to_c_type(selection)));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Clipboard> Widget::get_clipboard(const Glib::ustring& selection) const
{

  Glib::RefPtr<const Clipboard> retvalue = Glib::wrap(gtk_widget_get_clipboard(const_cast<GtkWidget*>(gobj()), Gdk::AtomString::to_c_type(selection)));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Atk::Object> Widget::get_accessible()
{

  Glib::RefPtr<Atk::Object> retvalue = Glib::wrap(gtk_widget_get_accessible(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

void Widget::set_colormap(const Glib::RefPtr<const Gdk::Colormap> & colormap)
{
  gtk_widget_set_colormap(gobj(), const_cast<GdkColormap*>(Glib::unwrap<Gdk::Colormap>(colormap)));
}

Gdk::EventMask Widget::get_events() const
{
  return static_cast<Gdk::EventMask>(gtk_widget_get_events(const_cast<GtkWidget*>(gobj())));
}

void Widget::get_pointer(int & x, int & y) const
{
  gtk_widget_get_pointer(const_cast<GtkWidget*>(gobj()), &x, &y);
}

bool Widget::is_ancestor(Widget & ancestor) const
{
  return gtk_widget_is_ancestor(const_cast<GtkWidget*>(gobj()), (ancestor).gobj());
}

bool Widget::translate_coordinates(Widget& dest_widget, int src_x, int src_y, int& dest_x, int& dest_y)
{
  return gtk_widget_translate_coordinates(gobj(), (dest_widget).gobj(), src_x, src_y, &dest_x, &dest_y);
}

void Widget::set_style(const Glib::RefPtr<Style>& style)
{
  gtk_widget_set_style(gobj(), Glib::unwrap(style));
}

void Widget::ensure_style()
{
  gtk_widget_ensure_style(gobj());
}

Glib::RefPtr<Style> Widget::get_style()
{

  Glib::RefPtr<Style> retvalue = Glib::wrap(gtk_widget_get_style(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Style> Widget::get_style() const
{

  Glib::RefPtr<const Style> retvalue = Glib::wrap(gtk_widget_get_style(const_cast<GtkWidget*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

void Widget::modify_style(const Glib::RefPtr<RcStyle>& style)
{
  gtk_widget_modify_style(gobj(), Glib::unwrap(style));
}

Glib::RefPtr<RcStyle> Widget::get_modifier_style()
{

  Glib::RefPtr<RcStyle> retvalue = Glib::wrap(gtk_widget_get_modifier_style(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const RcStyle> Widget::get_modifier_style() const
{

  Glib::RefPtr<const RcStyle> retvalue = Glib::wrap(gtk_widget_get_modifier_style(const_cast<GtkWidget*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

void Widget::modify_fg(StateType state, const Gdk::Color& color)
{
  gtk_widget_modify_fg(gobj(), ((GtkStateType)(state)), (color).gobj());
}

void Widget::modify_bg(StateType state, const Gdk::Color& color)
{
  gtk_widget_modify_bg(gobj(), ((GtkStateType)(state)), (color).gobj());
}

void Widget::modify_text(StateType state, const Gdk::Color& color)
{
  gtk_widget_modify_text(gobj(), ((GtkStateType)(state)), (color).gobj());
}

void Widget::modify_base(StateType state, const Gdk::Color& color)
{
  gtk_widget_modify_base(gobj(), ((GtkStateType)(state)), (color).gobj());
}

void Widget::modify_font(const Pango::FontDescription& font_desc)
{
  gtk_widget_modify_font(gobj(), const_cast<PangoFontDescription*>((font_desc).gobj()));
}

Glib::RefPtr<Pango::Context> Widget::create_pango_context()
{
  return Glib::wrap(gtk_widget_create_pango_context(gobj()));
}

Glib::RefPtr<Pango::Context> Widget::get_pango_context()
{

  Glib::RefPtr<Pango::Context> retvalue = Glib::wrap(gtk_widget_get_pango_context(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Pango::Layout> Widget::create_pango_layout(const Glib::ustring& text)
{
  return Glib::wrap(gtk_widget_create_pango_layout(gobj(), text.c_str()));
}

Glib::RefPtr<Gdk::Pixbuf> Widget::render_icon(const StockID& stock_id, IconSize size, const Glib::ustring& detail)
{
  return Glib::wrap(gtk_widget_render_icon(gobj(), (stock_id).get_c_str(), static_cast<GtkIconSize>(int(size)), detail.c_str()));
}

void Widget::set_composite_name(const Glib::ustring& name)
{
  gtk_widget_set_composite_name(gobj(), name.c_str());
}

Glib::ustring Widget::get_composite_name() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_widget_get_composite_name(const_cast<GtkWidget*>(gobj())));
}

void Widget::reset_rc_styles()
{
  gtk_widget_reset_rc_styles(gobj());
}

void Widget::push_colormap(const Glib::RefPtr<const Gdk::Colormap>& cmap)
{
  gtk_widget_push_colormap(const_cast<GdkColormap*>(Glib::unwrap<Gdk::Colormap>(cmap)));
}

void Widget::pop_colormap()
{
  gtk_widget_pop_colormap();
}

void Widget::push_composite_child()
{
  gtk_widget_push_composite_child();
}

void Widget::pop_composite_child()
{
  gtk_widget_pop_composite_child();
}

void Widget::set_default_colormap(const Glib::RefPtr<const Gdk::Colormap>& colormap)
{
  gtk_widget_set_default_colormap(const_cast<GdkColormap*>(Glib::unwrap<Gdk::Colormap>(colormap)));
}

Glib::RefPtr<Style> Widget::get_default_style()
{

  Glib::RefPtr<Style> retvalue = Glib::wrap(gtk_widget_get_default_style());

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Gdk::Colormap> Widget::get_default_colormap()
{

  Glib::RefPtr<Gdk::Colormap> retvalue = Glib::wrap(gtk_widget_get_default_colormap());

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<Gdk::Visual> Widget::get_default_visual()
{

  Glib::RefPtr<Gdk::Visual> retvalue = Glib::wrap(gtk_widget_get_default_visual());

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

void Widget::set_direction(TextDirection dir)
{
  gtk_widget_set_direction(gobj(), ((GtkTextDirection)(dir)));
}

TextDirection Widget::get_direction()
{
  return ((TextDirection)(gtk_widget_get_direction(gobj())));
}

void Widget::set_default_direction(TextDirection dir)
{
  gtk_widget_set_default_direction(((GtkTextDirection)(dir)));
}

TextDirection Widget::get_default_direction()
{
  return ((TextDirection)(gtk_widget_get_default_direction()));
}

void Widget::shape_combine_mask(const Glib::RefPtr<const Gdk::Bitmap>& shape_mask, int offset_x, int offset_y)
{
  gtk_widget_shape_combine_mask(gobj(), const_cast<GdkBitmap*>(Glib::unwrap<Gdk::Bitmap>(shape_mask)), offset_x, offset_y);
}

void Widget::reset_shapes()
{
  gtk_widget_reset_shapes(gobj());
}

Glib::ListHandle<Widget*> Widget::list_mnemonic_labels()
{
  return Glib::ListHandle<Widget*>(gtk_widget_list_mnemonic_labels(gobj()), Glib::OWNERSHIP_SHALLOW);
}

Glib::ListHandle<const Widget*> Widget::list_mnemonic_labels() const
{
  return Glib::ListHandle<const Widget*>(gtk_widget_list_mnemonic_labels(const_cast<GtkWidget*>(gobj())), Glib::OWNERSHIP_SHALLOW);
}

void Widget::add_mnemonic_label(Widget& label)
{
  gtk_widget_add_mnemonic_label(gobj(), (label).gobj());
}

void Widget::remove_mnemonic_label(Widget& label)
{
  gtk_widget_remove_mnemonic_label(gobj(), (label).gobj());
}

void Widget::drag_get_data(const Glib::RefPtr<Gdk::DragContext>& context, Glib::ustring& target, guint32 time)
{
  gtk_drag_get_data(gobj(), Glib::unwrap(context), Gdk::AtomString::to_c_type(target), time);
}

void Widget::drag_highlight()
{
  gtk_drag_highlight(gobj());
}

void Widget::drag_unhighlight()
{
  gtk_drag_unhighlight(gobj());
}

void Widget::drag_dest_set_proxy(const Glib::RefPtr<Gdk::Window>& proxy_window, Gdk::DragProtocol protocol, bool use_coordinates)
{
  gtk_drag_dest_set_proxy(gobj(), Glib::unwrap(proxy_window), ((GdkDragProtocol)(protocol)), static_cast<int>(use_coordinates));
}

void Widget::drag_dest_unset()
{
  gtk_drag_dest_unset(gobj());
}

Glib::ustring Widget::drag_dest_find_target(const Glib::RefPtr<Gdk::DragContext>& context, const Glib::RefPtr<TargetList>& target_list) const
{
  return Gdk::AtomString::to_cpp_type(gtk_drag_dest_find_target(const_cast<GtkWidget*>(gobj()), Glib::unwrap(context), const_cast<GtkTargetList*>(Glib::unwrap(target_list))));
}

Glib::RefPtr<TargetList> Widget::drag_dest_get_target_list()
{

  Glib::RefPtr<TargetList> retvalue = Glib::wrap(gtk_drag_dest_get_target_list(gobj()));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const TargetList> Widget::drag_dest_get_target_list() const
{

  Glib::RefPtr<const TargetList> retvalue = Glib::wrap(gtk_drag_dest_get_target_list(const_cast<GtkWidget*>(gobj())));

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

void Widget::drag_dest_set_target_list(const Glib::RefPtr<TargetList>& target_list)
{
  gtk_drag_dest_set_target_list(gobj(), const_cast<GtkTargetList*>(Glib::unwrap(target_list)));
}

void Widget::drag_dest_add_text_targets()
{
  gtk_drag_dest_add_text_targets(gobj());
}

void Widget::drag_dest_add_image_targets()
{
  gtk_drag_dest_add_image_targets(gobj());
}

void Widget::drag_dest_add_uri_targets()
{
  gtk_drag_dest_add_uri_targets(gobj());
}

void Widget::drag_source_unset()
{
  gtk_drag_source_unset(gobj());
}

void Widget::drag_source_set_icon(const Glib::RefPtr<Gdk::Colormap>& colormap, const Glib::RefPtr<Gdk::Pixmap>& pixmap, const Glib::RefPtr<Gdk::Bitmap>& mask)
{
  gtk_drag_source_set_icon(gobj(), Glib::unwrap(colormap), Glib::unwrap(pixmap), Glib::unwrap(mask));
}

void Widget::drag_source_set_icon(const Glib::RefPtr<Gdk::Pixbuf>& pixbuf)
{
  gtk_drag_source_set_icon_pixbuf(gobj(), Glib::unwrap(pixbuf));
}

void Widget::drag_source_set_icon(const StockID& stock_id)
{
  gtk_drag_source_set_icon_stock(gobj(), (stock_id).get_c_str());
}

void Widget::drag_source_add_text_targets()
{
  gtk_drag_source_add_text_targets(gobj());
}

void Widget::drag_source_add_uri_targets()
{
  gtk_drag_source_add_uri_targets(gobj());
}

void Widget::drag_source_add_image_targets()
{
  gtk_drag_source_add_image_targets(gobj());
}

Glib::RefPtr<Gdk::DragContext> Widget::drag_begin(const Glib::RefPtr<TargetList>& targets, Gdk::DragAction actions, int button, GdkEvent* event)
{

  Glib::RefPtr<Gdk::DragContext> retvalue = Glib::wrap(gtk_drag_begin(gobj(), const_cast<GtkTargetList*>(Glib::unwrap(targets)), ((GdkDragAction)(actions)), button, event), true);

  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

bool Widget::drag_check_threshold(int start_x, int start_y, int current_x, int current_y)
{
  return gtk_drag_check_threshold(gobj(), start_x, start_y, current_x, current_y);
}

void Widget::queue_resize_no_redraw()
{
  gtk_widget_queue_resize_no_redraw(gobj());
}

bool Widget::get_no_show_all() const
{
  return gtk_widget_get_no_show_all(const_cast<GtkWidget*>(gobj()));
}

void Widget::set_no_show_all(bool no_show_all)
{
  gtk_widget_set_no_show_all(gobj(), static_cast<int>(no_show_all));
}

void Widget::set_parent(Widget& parent)
{
  gtk_widget_set_parent(gobj(), (parent).gobj());
}

void Widget::unparent()
{
  gtk_widget_unparent(gobj());
}

Gtk::StateType Widget::get_state() const
{
  return static_cast<StateType>(gobj()->state);
}

Gtk::StateType Widget::get_saved_state() const
{
  return static_cast<StateType>(gobj()->saved_state);
}

Requisition Widget::get_requisition() const
{
  return (Requisition)(gobj()->requisition);
}

Allocation Widget::get_allocation() const
{
  return (Allocation)(Glib::wrap(&gobj()->allocation));
}

Glib::RefPtr<Gdk::Window> Widget::get_window()
{
  Glib::RefPtr<Gdk::Window> ref_ptr(Glib::wrap((GdkWindowObject*)(gobj()->window)));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}

Glib::RefPtr<const Gdk::Window> Widget::get_window() const
{
  Glib::RefPtr<const Gdk::Window> ref_ptr(Glib::wrap((GdkWindowObject*)(gobj()->window)));

  if(ref_ptr)
    ref_ptr->reference();

  return ref_ptr;
}

Widget::Widget()
:
  Glib::ObjectBase(0), //Mark this class as gtkmmproc-generated, rather than a custom class, to allow vfunc optimisations.
  Gtk::Object(Glib::ConstructParams(widget_class_.init()))
{
  }

void Widget::map()
{
  gtk_widget_map(gobj());
}

void Widget::unmap()
{
  gtk_widget_unmap(gobj());
}

void Widget::realize()
{
  gtk_widget_realize(gobj());
}

void Widget::unrealize()
{
  gtk_widget_unrealize(gobj());
}

void Widget::get_child_requisition(Requisition& requisition) const
{
  gtk_widget_get_child_requisition(const_cast<GtkWidget*>(gobj()), (GtkRequisition*)(&requisition));
}

void Widget::get_style_property_value(const Glib::ustring& the_property_name, Glib::ValueBase& value) const
{
  gtk_widget_style_get_property(const_cast<GtkWidget*>(gobj()), the_property_name.c_str(), (value).gobj());
}

void Widget::set_allocation(const Allocation& value)
{
  gobj()->allocation = (GtkAllocation)(*(value.gobj()));
}

void Widget::set_window(const Glib::RefPtr<Gdk::Window>& value)
{
  Glib::RefPtr<Gdk::Window> valueOld(Glib::wrap((GdkWindowObject*)(gobj()->window))); //Take possession of the old one, unref-ing it in the destructor.

  if(value)
    value->reference(); //Ref once for the recipient.

  gobj()->window = Glib::unwrap(value);
}


Glib::SignalProxy0< void > Widget::signal_show()
{
  return Glib::SignalProxy0< void >(this, &Widget_signal_show_info);
}

Glib::SignalProxy0< void > Widget::signal_hide()
{
  return Glib::SignalProxy0< void >(this, &Widget_signal_hide_info);
}

Glib::SignalProxy0< void > Widget::signal_map()
{
  return Glib::SignalProxy0< void >(this, &Widget_signal_map_info);
}

Glib::SignalProxy0< void > Widget::signal_unmap()
{
  return Glib::SignalProxy0< void >(this, &Widget_signal_unmap_info);
}

Glib::SignalProxy0< void > Widget::signal_realize()
{
  return Glib::SignalProxy0< void >(this, &Widget_signal_realize_info);
}

Glib::SignalProxy0< void > Widget::signal_unrealize()
{
  return Glib::SignalProxy0< void >(this, &Widget_signal_unrealize_info);
}

Glib::SignalProxy1< void,Requisition* > Widget::signal_size_request()
{
  return Glib::SignalProxy1< void,Requisition* >(this, &Widget_signal_size_request_info);
}

Glib::SignalProxy1< void,Allocation& > Widget::signal_size_allocate()
{
  return Glib::SignalProxy1< void,Allocation& >(this, &Widget_signal_size_allocate_info);
}

Glib::SignalProxy1< void,Gtk::StateType > Widget::signal_state_changed()
{
  return Glib::SignalProxy1< void,Gtk::StateType >(this, &Widget_signal_state_changed_info);
}

Glib::SignalProxy1< void,Widget* > Widget::signal_parent_changed()
{
  return Glib::SignalProxy1< void,Widget* >(this, &Widget_signal_parent_changed_info);
}

Glib::SignalProxy1< void,Widget* > Widget::signal_hierarchy_changed()
{
  return Glib::SignalProxy1< void,Widget* >(this, &Widget_signal_hierarchy_changed_info);
}

Glib::SignalProxy1< void,const Glib::RefPtr<Style>& > Widget::signal_style_changed()
{
  return Glib::SignalProxy1< void,const Glib::RefPtr<Style>& >(this, &Widget_signal_style_changed_info);
}

Glib::SignalProxy1< void,TextDirection > Widget::signal_direction_changed()
{
  return Glib::SignalProxy1< void,TextDirection >(this, &Widget_signal_direction_changed_info);
}

Glib::SignalProxy1< void,bool > Widget::signal_grab_notify()
{
  return Glib::SignalProxy1< void,bool >(this, &Widget_signal_grab_notify_info);
}

Glib::SignalProxy1< void,GParamSpec* > Widget::signal_child_notify()
{
  return Glib::SignalProxy1< void,GParamSpec* >(this, &Widget_signal_child_notify_info);
}

Glib::SignalProxy1< bool,bool > Widget::signal_mnemonic_activate()
{
  return Glib::SignalProxy1< bool,bool >(this, &Widget_signal_mnemonic_activate_info);
}

Glib::SignalProxy0< void > Widget::signal_grab_focus()
{
  return Glib::SignalProxy0< void >(this, &Widget_signal_grab_focus_info);
}

Glib::SignalProxy1< bool,DirectionType > Widget::signal_focus()
{
  return Glib::SignalProxy1< bool,DirectionType >(this, &Widget_signal_focus_info);
}

Glib::SignalProxy1< bool,GdkEvent* > Widget::signal_event()
{
  return Glib::SignalProxy1< bool,GdkEvent* >(this, &Widget_signal_event_info);
}

Glib::SignalProxy1< void,GdkEvent* > Widget::signal_event_after()
{
  return Glib::SignalProxy1< void,GdkEvent* >(this, &Widget_signal_event_after_info);
}

Glib::SignalProxy1< bool,GdkEventButton* > Widget::signal_button_press_event()
{
  return Glib::SignalProxy1< bool,GdkEventButton* >(this, &Widget_signal_button_press_event_info);
}

Glib::SignalProxy1< bool,GdkEventButton* > Widget::signal_button_release_event()
{
  return Glib::SignalProxy1< bool,GdkEventButton* >(this, &Widget_signal_button_release_event_info);
}

Glib::SignalProxy1< bool,GdkEventScroll* > Widget::signal_scroll_event()
{
  return Glib::SignalProxy1< bool,GdkEventScroll* >(this, &Widget_signal_scroll_event_info);
}

Glib::SignalProxy1< bool,GdkEventMotion* > Widget::signal_motion_notify_event()
{
  return Glib::SignalProxy1< bool,GdkEventMotion* >(this, &Widget_signal_motion_notify_event_info);
}

Glib::SignalProxy1< bool,GdkEventAny* > Widget::signal_delete_event()
{
  return Glib::SignalProxy1< bool,GdkEventAny* >(this, &Widget_signal_delete_event_info);
}

Glib::SignalProxy1< bool,GdkEventExpose* > Widget::signal_expose_event()
{
  return Glib::SignalProxy1< bool,GdkEventExpose* >(this, &Widget_signal_expose_event_info);
}

Glib::SignalProxy1< bool,GdkEventKey* > Widget::signal_key_press_event()
{
  return Glib::SignalProxy1< bool,GdkEventKey* >(this, &Widget_signal_key_press_event_info);
}

Glib::SignalProxy1< bool,GdkEventKey* > Widget::signal_key_release_event()
{
  return Glib::SignalProxy1< bool,GdkEventKey* >(this, &Widget_signal_key_release_event_info);
}

Glib::SignalProxy1< bool,GdkEventCrossing* > Widget::signal_enter_notify_event()
{
  return Glib::SignalProxy1< bool,GdkEventCrossing* >(this, &Widget_signal_enter_notify_event_info);
}

Glib::SignalProxy1< bool,GdkEventCrossing* > Widget::signal_leave_notify_event()
{
  return Glib::SignalProxy1< bool,GdkEventCrossing* >(this, &Widget_signal_leave_notify_event_info);
}

Glib::SignalProxy1< bool,GdkEventConfigure* > Widget::signal_configure_event()
{
  return Glib::SignalProxy1< bool,GdkEventConfigure* >(this, &Widget_signal_configure_event_info);
}

Glib::SignalProxy1< bool,GdkEventFocus* > Widget::signal_focus_in_event()
{
  return Glib::SignalProxy1< bool,GdkEventFocus* >(this, &Widget_signal_focus_in_event_info);
}

Glib::SignalProxy1< bool,GdkEventFocus* > Widget::signal_focus_out_event()
{
  return Glib::SignalProxy1< bool,GdkEventFocus* >(this, &Widget_signal_focus_out_event_info);
}

Glib::SignalProxy1< bool,GdkEventAny* > Widget::signal_map_event()
{
  return Glib::SignalProxy1< bool,GdkEventAny* >(this, &Widget_signal_map_event_info);
}

Glib::SignalProxy1< bool,GdkEventAny* > Widget::signal_unmap_event()
{
  return Glib::SignalProxy1< bool,GdkEventAny* >(this, &Widget_signal_unmap_event_info);
}

Glib::SignalProxy1< bool,GdkEventProperty* > Widget::signal_property_notify_event()
{
  return Glib::SignalProxy1< bool,GdkEventProperty* >(this, &Widget_signal_property_notify_event_info);
}

Glib::SignalProxy1< bool,GdkEventSelection* > Widget::signal_selection_clear_event()
{
  return Glib::SignalProxy1< bool,GdkEventSelection* >(this, &Widget_signal_selection_clear_event_info);
}

Glib::SignalProxy1< bool,GdkEventSelection* > Widget::signal_selection_request_event()
{
  return Glib::SignalProxy1< bool,GdkEventSelection* >(this, &Widget_signal_selection_request_event_info);
}

Glib::SignalProxy1< bool,GdkEventSelection* > Widget::signal_selection_notify_event()
{
  return Glib::SignalProxy1< bool,GdkEventSelection* >(this, &Widget_signal_selection_notify_event_info);
}

Glib::SignalProxy1< bool,GdkEventProximity* > Widget::signal_proximity_in_event()
{
  return Glib::SignalProxy1< bool,GdkEventProximity* >(this, &Widget_signal_proximity_in_event_info);
}

Glib::SignalProxy1< bool,GdkEventProximity* > Widget::signal_proximity_out_event()
{
  return Glib::SignalProxy1< bool,GdkEventProximity* >(this, &Widget_signal_proximity_out_event_info);
}

Glib::SignalProxy1< bool,GdkEventVisibility* > Widget::signal_visibility_notify_event()
{
  return Glib::SignalProxy1< bool,GdkEventVisibility* >(this, &Widget_signal_visibility_notify_event_info);
}

Glib::SignalProxy1< bool,GdkEventClient* > Widget::signal_client_event()
{
  return Glib::SignalProxy1< bool,GdkEventClient* >(this, &Widget_signal_client_event_info);
}

Glib::SignalProxy1< bool,GdkEventAny* > Widget::signal_no_expose_event()
{
  return Glib::SignalProxy1< bool,GdkEventAny* >(this, &Widget_signal_no_expose_event_info);
}

Glib::SignalProxy1< bool,GdkEventWindowState* > Widget::signal_window_state_event()
{
  return Glib::SignalProxy1< bool,GdkEventWindowState* >(this, &Widget_signal_window_state_event_info);
}

Glib::SignalProxy3< void,SelectionData&,guint,guint > Widget::signal_selection_get()
{
  return Glib::SignalProxy3< void,SelectionData&,guint,guint >(this, &Widget_signal_selection_get_info);
}

Glib::SignalProxy2< void,const SelectionData&,guint > Widget::signal_selection_received()
{
  return Glib::SignalProxy2< void,const SelectionData&,guint >(this, &Widget_signal_selection_received_info);
}

Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& > Widget::signal_drag_begin()
{
  return Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& >(this, &Widget_signal_drag_begin_info);
}

Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& > Widget::signal_drag_end()
{
  return Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& >(this, &Widget_signal_drag_end_info);
}

Glib::SignalProxy4< void,const Glib::RefPtr<Gdk::DragContext>&,SelectionData&,guint,guint > Widget::signal_drag_data_get()
{
  return Glib::SignalProxy4< void,const Glib::RefPtr<Gdk::DragContext>&,SelectionData&,guint,guint >(this, &Widget_signal_drag_data_get_info);
}

Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& > Widget::signal_drag_data_delete()
{
  return Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::DragContext>& >(this, &Widget_signal_drag_data_delete_info);
}

Glib::SignalProxy2< void,const Glib::RefPtr<Gdk::DragContext>&,guint > Widget::signal_drag_leave()
{
  return Glib::SignalProxy2< void,const Glib::RefPtr<Gdk::DragContext>&,guint >(this, &Widget_signal_drag_leave_info);
}

Glib::SignalProxy4< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > Widget::signal_drag_motion()
{
  return Glib::SignalProxy4< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint >(this, &Widget_signal_drag_motion_info);
}

Glib::SignalProxy4< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint > Widget::signal_drag_drop()
{
  return Glib::SignalProxy4< bool,const Glib::RefPtr<Gdk::DragContext>&,int,int,guint >(this, &Widget_signal_drag_drop_info);
}

Glib::SignalProxy6< void,const Glib::RefPtr<Gdk::DragContext>&,int,int,const SelectionData&,guint,guint > Widget::signal_drag_data_received()
{
  return Glib::SignalProxy6< void,const Glib::RefPtr<Gdk::DragContext>&,int,int,const SelectionData&,guint,guint >(this, &Widget_signal_drag_data_received_info);
}

Glib::SignalProxy0< Glib::RefPtr<Atk::Object> > Widget::signal_get_accessible()
{
  return Glib::SignalProxy0< Glib::RefPtr<Atk::Object> >(this, &Widget_signal_get_accessible_info);
}

Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::Screen>& > Widget::signal_screen_changed()
{
  return Glib::SignalProxy1< void,const Glib::RefPtr<Gdk::Screen>& >(this, &Widget_signal_screen_changed_info);
}


Glib::PropertyProxy<Glib::ustring> Widget::property_name() 
{
  return Glib::PropertyProxy<Glib::ustring>(this, "name");
}

Glib::PropertyProxy_ReadOnly<Glib::ustring> Widget::property_name() const
{
  return Glib::PropertyProxy_ReadOnly<Glib::ustring>(this, "name");
}

Glib::PropertyProxy<Container*> Widget::property_parent() 
{
  return Glib::PropertyProxy<Container*>(this, "parent");
}

Glib::PropertyProxy_ReadOnly<Container*> Widget::property_parent() const
{
  return Glib::PropertyProxy_ReadOnly<Container*>(this, "parent");
}

Glib::PropertyProxy<int> Widget::property_width_request() 
{
  return Glib::PropertyProxy<int>(this, "width-request");
}

Glib::PropertyProxy_ReadOnly<int> Widget::property_width_request() const
{
  return Glib::PropertyProxy_ReadOnly<int>(this, "width-request");
}

Glib::PropertyProxy<int> Widget::property_height_request() 
{
  return Glib::PropertyProxy<int>(this, "height-request");
}

Glib::PropertyProxy_ReadOnly<int> Widget::property_height_request() const
{
  return Glib::PropertyProxy_ReadOnly<int>(this, "height-request");
}

Glib::PropertyProxy<bool> Widget::property_visible() 
{
  return Glib::PropertyProxy<bool>(this, "visible");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_visible() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "visible");
}

Glib::PropertyProxy<bool> Widget::property_sensitive() 
{
  return Glib::PropertyProxy<bool>(this, "sensitive");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_sensitive() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "sensitive");
}

Glib::PropertyProxy<bool> Widget::property_app_paintable() 
{
  return Glib::PropertyProxy<bool>(this, "app-paintable");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_app_paintable() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "app-paintable");
}

Glib::PropertyProxy<bool> Widget::property_can_focus() 
{
  return Glib::PropertyProxy<bool>(this, "can-focus");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_can_focus() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "can-focus");
}

Glib::PropertyProxy<bool> Widget::property_has_focus() 
{
  return Glib::PropertyProxy<bool>(this, "has-focus");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_has_focus() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "has-focus");
}

Glib::PropertyProxy<bool> Widget::property_can_default() 
{
  return Glib::PropertyProxy<bool>(this, "can-default");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_can_default() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "can-default");
}

Glib::PropertyProxy<bool> Widget::property_has_default() 
{
  return Glib::PropertyProxy<bool>(this, "has-default");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_has_default() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "has-default");
}

Glib::PropertyProxy<bool> Widget::property_receives_default() 
{
  return Glib::PropertyProxy<bool>(this, "receives-default");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_receives_default() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "receives-default");
}

Glib::PropertyProxy_ReadOnly<bool> Widget::property_composite_child() const
{
  return Glib::PropertyProxy_ReadOnly<bool>(this, "composite-child");
}

Glib::PropertyProxy< Glib::RefPtr<Style> > Widget::property_style() 
{
  return Glib::PropertyProxy< Glib::RefPtr<Style> >(this, "style");
}

Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Style> > Widget::property_style() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Style> >(this, "style");
}

Glib::PropertyProxy<Gdk::EventMask> Widget::property_events() 
{
  return Glib::PropertyProxy<Gdk::EventMask>(this, "events");
}

Glib::PropertyProxy_ReadOnly<Gdk::EventMask> Widget::property_events() const
{
  return Glib::PropertyProxy_ReadOnly<Gdk::EventMask>(this, "events");
}

Glib::PropertyProxy<Gdk::ExtensionMode> Widget::property_extension_events() 
{
  return Glib::PropertyProxy<Gdk::ExtensionMode>(this, "extension-events");
}

Glib::PropertyProxy_ReadOnly<Gdk::ExtensionMode> Widget::property_extension_events() const
{
  return Glib::PropertyProxy_ReadOnly<Gdk::ExtensionMode>(this, "extension-events");
}


void Gtk::Widget::on_show()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->show)
    (*base->show)(gobj());
}

void Gtk::Widget::on_hide()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->hide)
    (*base->hide)(gobj());
}

void Gtk::Widget::on_map()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->map)
    (*base->map)(gobj());
}

void Gtk::Widget::on_unmap()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->unmap)
    (*base->unmap)(gobj());
}

void Gtk::Widget::on_realize()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->realize)
    (*base->realize)(gobj());
}

void Gtk::Widget::on_unrealize()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->unrealize)
    (*base->unrealize)(gobj());
}

void Gtk::Widget::on_size_request(Requisition* requisition)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->size_request)
    (*base->size_request)(gobj(),(GtkRequisition*)(requisition));
}

void Gtk::Widget::on_size_allocate(Allocation& allocation)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->size_allocate)
    (*base->size_allocate)(gobj(),(GtkAllocation*)(allocation.gobj()));
}

void Gtk::Widget::on_state_changed(Gtk::StateType previous_state)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->state_changed)
    (*base->state_changed)(gobj(),((GtkStateType)(previous_state)));
}

void Gtk::Widget::on_parent_changed(Widget* previous_parent)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->parent_set)
    (*base->parent_set)(gobj(),(GtkWidget*)Glib::unwrap(previous_parent));
}

void Gtk::Widget::on_hierarchy_changed(Widget* previous_toplevel)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->hierarchy_changed)
    (*base->hierarchy_changed)(gobj(),(GtkWidget*)Glib::unwrap(previous_toplevel));
}

void Gtk::Widget::on_style_changed(const Glib::RefPtr<Style>& previous_style)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->style_set)
    (*base->style_set)(gobj(),Glib::unwrap(previous_style));
}

void Gtk::Widget::on_direction_changed(TextDirection direction)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->direction_changed)
    (*base->direction_changed)(gobj(),((GtkTextDirection)(direction)));
}

void Gtk::Widget::on_grab_notify(bool was_grabbed)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->grab_notify)
    (*base->grab_notify)(gobj(),static_cast<int>(was_grabbed));
}

void Gtk::Widget::on_child_notify(GParamSpec* pspec)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->child_notify)
    (*base->child_notify)(gobj(),pspec);
}

bool Gtk::Widget::on_mnemonic_activate(bool group_cycling)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->mnemonic_activate)
    return (*base->mnemonic_activate)(gobj(),static_cast<int>(group_cycling));

  typedef bool RType;
  return RType();
}

void Gtk::Widget::on_grab_focus()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->grab_focus)
    (*base->grab_focus)(gobj());
}

bool Gtk::Widget::on_focus(DirectionType direction)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->focus)
    return (*base->focus)(gobj(),((GtkDirectionType)(direction)));

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_event(GdkEvent* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->event)
    return (*base->event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_button_press_event(GdkEventButton* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->button_press_event)
    return (*base->button_press_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_button_release_event(GdkEventButton* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->button_release_event)
    return (*base->button_release_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_scroll_event(GdkEventScroll* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->scroll_event)
    return (*base->scroll_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_motion_notify_event(GdkEventMotion* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->motion_notify_event)
    return (*base->motion_notify_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_delete_event(GdkEventAny* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->delete_event)
    return (*base->delete_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_expose_event(GdkEventExpose* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->expose_event)
    return (*base->expose_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_key_press_event(GdkEventKey* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->key_press_event)
    return (*base->key_press_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_key_release_event(GdkEventKey* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->key_release_event)
    return (*base->key_release_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_enter_notify_event(GdkEventCrossing* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->enter_notify_event)
    return (*base->enter_notify_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_leave_notify_event(GdkEventCrossing* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->leave_notify_event)
    return (*base->leave_notify_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_configure_event(GdkEventConfigure* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->configure_event)
    return (*base->configure_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_focus_in_event(GdkEventFocus* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->focus_in_event)
    return (*base->focus_in_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_focus_out_event(GdkEventFocus* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->focus_out_event)
    return (*base->focus_out_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_map_event(GdkEventAny* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->map_event)
    return (*base->map_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_unmap_event(GdkEventAny* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->unmap_event)
    return (*base->unmap_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_property_notify_event(GdkEventProperty* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->property_notify_event)
    return (*base->property_notify_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_selection_clear_event(GdkEventSelection* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->selection_clear_event)
    return (*base->selection_clear_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_selection_request_event(GdkEventSelection* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->selection_request_event)
    return (*base->selection_request_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_selection_notify_event(GdkEventSelection* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->selection_notify_event)
    return (*base->selection_notify_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_proximity_in_event(GdkEventProximity* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->proximity_in_event)
    return (*base->proximity_in_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_proximity_out_event(GdkEventProximity* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->proximity_out_event)
    return (*base->proximity_out_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_visibility_notify_event(GdkEventVisibility* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->visibility_notify_event)
    return (*base->visibility_notify_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_client_event(GdkEventClient* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->client_event)
    return (*base->client_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_no_expose_event(GdkEventAny* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->no_expose_event)
    return (*base->no_expose_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_window_state_event(GdkEventWindowState* event)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->window_state_event)
    return (*base->window_state_event)(gobj(),event);

  typedef bool RType;
  return RType();
}

void Gtk::Widget::on_selection_get(SelectionData& selection_data, guint info, guint time)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->selection_get)
    (*base->selection_get)(gobj(),(selection_data).gobj(),info,time);
}

void Gtk::Widget::on_selection_received(const SelectionData& selection_data, guint time)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->selection_received)
    (*base->selection_received)(gobj(),const_cast<GtkSelectionData*>((selection_data).gobj()),time);
}

void Gtk::Widget::on_drag_begin(const Glib::RefPtr<Gdk::DragContext>& context)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_begin)
    (*base->drag_begin)(gobj(),Glib::unwrap(context));
}

void Gtk::Widget::on_drag_end(const Glib::RefPtr<Gdk::DragContext>& context)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_end)
    (*base->drag_end)(gobj(),Glib::unwrap(context));
}

void Gtk::Widget::on_drag_data_get(const Glib::RefPtr<Gdk::DragContext>& context, SelectionData& selection_data, guint info, guint time)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_data_get)
    (*base->drag_data_get)(gobj(),Glib::unwrap(context),(selection_data).gobj(),info,time);
}

void Gtk::Widget::on_drag_data_delete(const Glib::RefPtr<Gdk::DragContext>& context)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_data_delete)
    (*base->drag_data_delete)(gobj(),Glib::unwrap(context));
}

void Gtk::Widget::on_drag_leave(const Glib::RefPtr<Gdk::DragContext>& context, guint time)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_leave)
    (*base->drag_leave)(gobj(),Glib::unwrap(context),time);
}

bool Gtk::Widget::on_drag_motion(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, guint time)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_motion)
    return (*base->drag_motion)(gobj(),Glib::unwrap(context),x,y,time);

  typedef bool RType;
  return RType();
}

bool Gtk::Widget::on_drag_drop(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, guint time)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_drop)
    return (*base->drag_drop)(gobj(),Glib::unwrap(context),x,y,time);

  typedef bool RType;
  return RType();
}

void Gtk::Widget::on_drag_data_received(const Glib::RefPtr<Gdk::DragContext>& context, int x, int y, const SelectionData& selection_data, guint info, guint time)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->drag_data_received)
    (*base->drag_data_received)(gobj(),Glib::unwrap(context),x,y,const_cast<GtkSelectionData*>((selection_data).gobj()),info,time);
}

Glib::RefPtr<Atk::Object> Gtk::Widget::on_get_accessible()
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->get_accessible)
    return Glib::wrap((*base->get_accessible)(gobj()), true);

  typedef Glib::RefPtr<Atk::Object> RType;
  return RType();
}

void Gtk::Widget::on_screen_changed(const Glib::RefPtr<Gdk::Screen>& previous_screen)
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->screen_changed)
    (*base->screen_changed)(gobj(),Glib::unwrap(previous_screen));
}


void Gtk::Widget::dispatch_child_properties_changed_vfunc(guint p1, GParamSpec** p2) 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->dispatch_child_properties_changed)
    (*base->dispatch_child_properties_changed)(gobj(),p1,p2);
}

void Gtk::Widget::show_all_vfunc() 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->show_all)
    (*base->show_all)(gobj());
}

void Gtk::Widget::hide_all_vfunc() 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->hide_all)
    (*base->hide_all)(gobj());
}

Glib::RefPtr<Atk::Object> Gtk::Widget::get_accessible_vfunc() 
{
  BaseClassType *const base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->get_accessible)
    return Glib::wrap((*base->get_accessible)(gobj()));

  typedef Glib::RefPtr<Atk::Object> RType;
  return RType();
}


} // namespace Gtk


