#!/usr/bin/python

import sys

if len(sys.argv) < 2:
    print 'Syntax: %s <path>' % sys.argv[0]
    sys.exit(1)

f = open(sys.argv[1], 'w')

print >>f,"""
/** THIS FILE IS AUTOGENERATED: DO NOT EDIT.
 *
 *  This file is generated by signals.h.py.
 */

#include <list>
#include <boost/function.hpp>
#include <boost/bind.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/enable_shared_from_this.hpp>
#include <boost/optional.hpp>
#include "pbd/stacktrace.h"

namespace PBD {

class Connection;

class SignalBase : public boost::enable_shared_from_this<SignalBase>
{
public:
	virtual ~SignalBase () {}
	virtual void disconnect (boost::shared_ptr<Connection>) = 0;

protected:
	boost::mutex _mutex;
};

class Connection : public boost::enable_shared_from_this<Connection>
{
public:
	Connection (boost::shared_ptr<SignalBase> b) : _signal (b) {}

	void disconnect ()
	{
		if (_signal) {
			_signal->disconnect (shared_from_this ());
		} 
	}

private:
	boost::shared_ptr<SignalBase> _signal;
};

template<typename R>
class OptionalLastValue
{
public:
	typedef boost::optional<R> result_type;

	template <typename Iter>
	result_type operator() (Iter first, Iter last) const {
		result_type r;
		while (first != last) {
			r = *first;
			++first;
		}

		return r;
	}
};
"""

def comma_separated(n, prefix = ""):
    r = ""
    for i in range(0, len(n)):
        if i > 0:
            r += ", "
        r += "%s%s" % (prefix, n[i])
    return r

def simple_signal(f, n, v):

    An = []
    for i in range(0, n):
        An.append("A%d" % (i + 1))

    if v:
        print >>f,"template <%s>" % comma_separated(An, "typename ")
        print >>f,"class SimpleSignal%d<%s> : public SignalBase" % (n, comma_separated(["void"] + An))
    else:
        print >>f,"template <%s>" % comma_separated(["R"] + An + ["C = OptionalLastValue<R> "], "typename ")
        print >>f,"class SimpleSignal%d : public SignalBase" % n

    print >>f,"{"
    print >>f,"public:"
    print >>f,""
    if v:
        print >>f,"\ttypedef boost::function<void(%s)> slot_function_type;" % comma_separated(An)
        print >>f,"\ttypedef void result_type;"
    else:
        print >>f,"\ttypedef boost::function<R(%s)> slot_function_type;" % comma_separated(An)
        print >>f,"\ttypedef boost::optional<R> result_type;"

    print >>f,"private:"
    print >>f,""

    print >>f,"""
	typedef std::map<boost::shared_ptr<Connection>, slot_function_type> Slots;
	Slots _slots;
"""

    print >>f,"public:"
    print >>f,""
    print >>f,"""
	boost::shared_ptr<Connection> connect (slot_function_type f)
	{
		boost::shared_ptr<Connection> c (new Connection (shared_from_this ()));
		boost::mutex::scoped_lock lm (_mutex);
		_slots[c] = f;
		return c;
	}
"""

    Anan = []
    for a in An:
        Anan.append('%s %s' % (a, a.lower()))

    an = []
    for a in An:
        an.append(a.lower())

    if v:
        print >>f,"\tvoid emit (%s)" % comma_separated(Anan)
    else:
        print >>f,"\ttypename C::result_type emit (%s)" % comma_separated(Anan)
    print >>f,"\t{"
    print >>f,"\t\tSlots s;"
    print >>f,"\t\t{"
    print >>f,"\t\t\tboost::mutex::scoped_lock lm (_mutex);"
    print >>f,"\t\t\ts = _slots;"
    print >>f,"\t\t}"
    if not v:
        print >>f,"\t\tstd::list<R> r;"
    if n == 0 and v:
        print >>f,"""
#if __GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ >= 6))                                                                      
                for (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {                                                 
#else                                                                                                                             
                for (Slots::iterator i = s.begin(); i != s.end(); ++i) {                                                          
#endif                                                                                                                               
"""
    else:
        print >>f,"\t\tfor (typename Slots::iterator i = s.begin(); i != s.end(); ++i) {"

    print >>f,"""
			bool still_there = false;
			{
				boost::mutex::scoped_lock lm (_mutex);
				still_there = _slots.find (i->first) != _slots.end ();
			}

			if (still_there) {"""
    if v:
        print >>f,"\t\t\t\t(i->second)(%s);" % comma_separated(an)
    else:
        print >>f,"\t\t\t\tr.push_back ((i->second)(%s));" % comma_separated(an)
    print >>f,"\t\t\t}"
    print >>f,"\t\t}"
    if not v:
        print >>f,"\t\tC c;"
        print >>f,"\t\treturn c (r.begin(), r.end());"
    print >>f,"\t}"

    print >>f,"""
	bool empty () {
		boost::mutex::scoped_lock lm (_mutex);
		return _slots.empty ();
	}
"""


    if v:
        tp = comma_separated(["void"] + An)
    else:
        tp = comma_separated(["R"] + An + ["C"])

    print >>f,"\tstatic boost::shared_ptr<SimpleSignal%d<%s> > create ()" % (n, tp)
    print >>f,"\t{"
    print >>f,"\t\treturn boost::shared_ptr<SimpleSignal%d<%s> > (new SimpleSignal%d<%s>);" % (n, tp, n, tp)
    print >>f,"\t}"
    
    print >>f,""
    print >>f,"private:"
    print >>f,""
    print >>f,"\tfriend class Connection;"
    print >>f,""
    print >>f,"\tSimpleSignal%d () {}" % n
    
    print >>f,"""
	void disconnect (boost::shared_ptr<Connection> c)
	{
		boost::mutex::scoped_lock lm (_mutex);
		_slots.erase (c);
	}
};    
"""


for i in range(0, 6):
    simple_signal(f, i, False)
    simple_signal(f, i, True)

print >>f,"}"
