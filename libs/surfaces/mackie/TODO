* if mackie wheel moves too fast, it's ignored.
* update manual with jog wheel states
* alsa/sequencer ports unstable. possibly problems with use of ::poll
* use glib::timeout for check_scrubbing
* crash when mmc port set to mcu?
* remappable buttons
* how long can UI signal callbacks take to execute? What happens if they block?
  where ENSURE_CORRECT_THREAD is a macro that is modelled on ENSURE_GUI_THREAD
  if the handler is not called in the "correct thread", it will use a pseudo-RT-safe-enough technique to get the correct thread to recall "handler" later on, and return.

* finish button implementations.
* concurrency for bank switching? And make sure "old" events aren't sent to "new" faders
* TODOs in code
* removal of a route results in a strip that isn't dead, but doesn't have any effect on the session
* use i18n. see string_compose

Later
-----
* remove commented couts
* Perhaps MackieControlProtocol shouldn't implement MackieButtonHandler
* talk to route plugins
* check for excessiveness (ie too many events making other subsystems work too hard)
* Queueing of writes?
* Generic surface code to common location
* bulk remote id changes cause too many surface updates. use Config->remote_model.
* which bank switching - overlap or dead faders? Option?
* signals for buttons?
* MackieControlProtocol in namespace Mackie?
* power-cycling of surface. fd_midiport doesn't close.
* mix busses and/or a "bus-only" bank/mode
* what about surfaces like Mackie C4 and BCR2000?

Need UI integration
-------------------
* Some indication on the UI of currently bank-switched-in routes?
  Useful for surfaces that don't have a scribble strip.
* use current zoom setting and snap state for jog wheel

Actual Mackie
-------------
* test Mackie surface object. Apparently led rings don't work. Stereo busses?
* timecode & 55 char displays
* midi bandwidth

Bugs
----

* definitely something wrong with remote_id assignment on session create
  (master strip assigned 0).
