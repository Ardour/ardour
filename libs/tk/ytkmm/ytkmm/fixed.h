// -*- c++ -*-
// Generated by gmmproc 2.45.3 -- DO NOT MODIFY!
#ifndef _GTKMM_FIXED_H
#define _GTKMM_FIXED_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

/* $Id: fixed.hg,v 1.1 2003/01/21 13:38:49 murrayc Exp $ */

/* fixed.h
 * 
 * Copyright (C) 1998-2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

 
#include <ytkmm/container.h>


#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GtkFixed GtkFixed;
typedef struct _GtkFixedClass GtkFixedClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gtk
{ class Fixed_Class; } // namespace Gtk
namespace Gtk
{

/** A container which allows you to position widgets at fixed coordinates.
 *
 * The Gtk::Fixed widget is a container which can place child widgets at fixed positions and with fixed sizes, given in pixels. It performs no automatic layout management.
 * For most applications, you should not use this container, because it will result in truncated text, overlapping widgets, and other display bugs:
 * - Themes may change widget sizes.
 * - Fonts other than the one you used to write the app will of course change the size of widgets containing text; keep in mind that users may use a larger font because of difficulty reading the default, or they may be using Windows or the framebuffer port of GTK+, where different fonts are available.
 * - Translation of text into other languages changes its size. Also, display of non-English text will use a different font in many cases.
 * In addition, the fixed widget can't properly be mirrored in right-to-left languages such as Hebrew and Arabic. i.e. normally GTK+ will flip the interface to put labels to the right of the thing they label, but it can't do that with Gtk::Fixed. So your application will not be usable in right-to-left languages.
 * Finally, fixed positioning makes it kind of annoying to add/remove GUI elements, since you have to reposition all the other elements. This is a long-term maintenance problem for your application.
 * If you know none of these things are an issue for your application, and prefer the simplicity of Gtk::Fixed, by all means use the widget. But you should be aware of the tradeoffs.
 *
 * @ingroup Widgets
 * @ingroup Containers
 */

class Fixed : public Container
{
  public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  typedef Fixed CppObjectType;
  typedef Fixed_Class CppClassType;
  typedef GtkFixed BaseObjectType;
  typedef GtkFixedClass BaseClassType;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

  virtual ~Fixed();

#ifndef DOXYGEN_SHOULD_SKIP_THIS

private:
  friend class Fixed_Class;
  static CppClassType fixed_class_;

  // noncopyable
  Fixed(const Fixed&);
  Fixed& operator=(const Fixed&);

protected:
  explicit Fixed(const Glib::ConstructParams& construct_params);
  explicit Fixed(GtkFixed* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  static GType get_type()      G_GNUC_CONST;


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GtkObject.
  GtkFixed*       gobj()       { return reinterpret_cast<GtkFixed*>(gobject_); }

  ///Provides access to the underlying C GtkObject.
  const GtkFixed* gobj() const { return reinterpret_cast<GtkFixed*>(gobject_); }


public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


private:

public:
  Fixed();

  
  void put(Widget& widget, int x, int y);
  
  void move(Widget& widget, int x, int y);
  
#ifndef GTKMM_DISABLE_DEPRECATED

  /** Sets whether a Gtk::Fixed widget is created with a separate
   * Gdk::Window for @a widget->window or not. (By default, it will be
   * created with no separate Gdk::Window). This function must be called
   * while the Gtk::Fixed is not realized, for instance, immediately after the
   * window is created.
   * 
   * This function was added to provide an easy migration path for
   * older applications which may expect Gtk::Fixed to have a separate window.
   * 
   * Deprecated: 2.20: Use Gtk::Widget::set_has_window() instead.
   * 
   * @param has_window <tt>true</tt> if a separate window should be created.
   */
  void set_has_window(bool has_window =  true);
#endif // GTKMM_DISABLE_DEPRECATED


#ifndef GTKMM_DISABLE_DEPRECATED

  /** Gets whether the Gtk::Fixed has its own Gdk::Window.
   * See set_has_window().
   * 
   * Deprecated: 2.20: Use Gtk::Widget::get_has_window() instead.
   * 
   * @return <tt>true</tt> if @a fixed has its own window.
   */
  bool get_has_window() const;
#endif // GTKMM_DISABLE_DEPRECATED


};

} /* namespace Gtk */


namespace Glib
{
  /** A Glib::wrap() method for this object.
   * 
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gtk::Fixed
   */
  Gtk::Fixed* wrap(GtkFixed* object, bool take_copy = false);
} //namespace Glib


#endif /* _GTKMM_FIXED_H */

